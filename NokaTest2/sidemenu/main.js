
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, t as text, a as space, b as attr_dev, c as add_location, f as toggle_class, g as insert_dev, h as append_dev, l as listen_dev, j as set_data_dev, p as prop_dev, n as noop, k as detach_dev, m as validate_each_argument, o as validate_each_keys, q as globals, u as update_keyed_each, r as destroy_block, w as create_slot, x as is_function, y as update_slot_base, z as get_all_dirty_from_scope, A as get_slot_changes, B as transition_in, C as transition_out, D as set_input_value, E as to_number, F as add_render_callback, G as binding_callbacks, H as bind, I as create_component, J as mount_component, K as add_flush_callback, L as destroy_component, M as onMount, N as afterUpdate, O as onDestroy, P as empty, Q as HtmlTag, R as assign, T as get_spread_update, U as get_spread_object, V as check_outros, W as group_outros } from './index.js';

const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)')
	.matches;

/* src/components/ThemeSwitcher.svelte generated by Svelte v3.47.0 */
const file$8 = "src/components/ThemeSwitcher.svelte";

function create_fragment$8(ctx) {
	let div;
	let t0;
	let t1;
	let label;
	let input;
	let input_aria_label_value;
	let input_checked_value;
	let t2;
	let span;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(/*initalTheme*/ ctx[1]);
			t1 = text(" theme\n\t");
			label = element("label");
			input = element("input");
			t2 = space();
			span = element("span");
			attr_dev(input, "id", "theme-switcher");
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "aria-label", input_aria_label_value = `Enable ${/*initalTheme*/ ctx[1]} theme`);
			input.checked = input_checked_value = /*currentTheme*/ ctx[2] === /*initalTheme*/ ctx[1];
			attr_dev(input, "class", "svelte-1j44x6d");
			add_location(input, file$8, 27, 2, 711);
			attr_dev(span, "class", "slider svelte-1j44x6d");
			add_location(span, file$8, 34, 2, 881);
			attr_dev(label, "class", "switch svelte-1j44x6d");
			attr_dev(label, "for", "theme-switcher");
			add_location(label, file$8, 26, 1, 665);
			attr_dev(div, "class", "theme-switcher svelte-1j44x6d");
			toggle_class(div, "dark", /*useDarkTheme*/ ctx[0]);
			add_location(div, file$8, 24, 0, 588);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, label);
			append_dev(label, input);
			append_dev(label, t2);
			append_dev(label, span);

			if (!mounted) {
				dispose = listen_dev(input, "click", /*toggleTheme*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*initalTheme*/ 2) set_data_dev(t0, /*initalTheme*/ ctx[1]);

			if (dirty & /*initalTheme*/ 2 && input_aria_label_value !== (input_aria_label_value = `Enable ${/*initalTheme*/ ctx[1]} theme`)) {
				attr_dev(input, "aria-label", input_aria_label_value);
			}

			if (dirty & /*currentTheme, initalTheme*/ 6 && input_checked_value !== (input_checked_value = /*currentTheme*/ ctx[2] === /*initalTheme*/ ctx[1])) {
				prop_dev(input, "checked", input_checked_value);
			}

			if (dirty & /*useDarkTheme*/ 1) {
				toggle_class(div, "dark", /*useDarkTheme*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ThemeSwitcher', slots, []);
	const THEMES = { dark: 'dark', light: 'light' };
	let isSystemThemeDark = false;
	let initalTheme;
	let currentTheme;
	let { useDarkTheme } = $$props;

	const toggleTheme = () => {
		$$invalidate(2, currentTheme = currentTheme === THEMES.dark
		? THEMES.light
		: THEMES.dark);

		if (localStorage) localStorage.theme = currentTheme;
	};

	const writable_props = ['useDarkTheme'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ThemeSwitcher> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('useDarkTheme' in $$props) $$invalidate(0, useDarkTheme = $$props.useDarkTheme);
	};

	$$self.$capture_state = () => ({
		isDarkMode,
		THEMES,
		isSystemThemeDark,
		initalTheme,
		currentTheme,
		useDarkTheme,
		toggleTheme
	});

	$$self.$inject_state = $$props => {
		if ('isSystemThemeDark' in $$props) $$invalidate(4, isSystemThemeDark = $$props.isSystemThemeDark);
		if ('initalTheme' in $$props) $$invalidate(1, initalTheme = $$props.initalTheme);
		if ('currentTheme' in $$props) $$invalidate(2, currentTheme = $$props.currentTheme);
		if ('useDarkTheme' in $$props) $$invalidate(0, useDarkTheme = $$props.useDarkTheme);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isSystemThemeDark, initalTheme, currentTheme*/ 22) {
			{
				$$invalidate(4, isSystemThemeDark = isDarkMode);
				$$invalidate(1, initalTheme = localStorage.theme || (isSystemThemeDark ? THEMES.dark : THEMES.light));
				$$invalidate(2, currentTheme = initalTheme);
				$$invalidate(0, useDarkTheme = currentTheme === THEMES.dark);
			}
		}
	};

	return [useDarkTheme, initalTheme, currentTheme, toggleTheme, isSystemThemeDark];
}

class ThemeSwitcher extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { useDarkTheme: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ThemeSwitcher",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*useDarkTheme*/ ctx[0] === undefined && !('useDarkTheme' in props)) {
			console.warn("<ThemeSwitcher> was created without expected prop 'useDarkTheme'");
		}
	}

	get useDarkTheme() {
		throw new Error("<ThemeSwitcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set useDarkTheme(value) {
		throw new Error("<ThemeSwitcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const exampleRoutes = [
	{
		name: 'Playground',
		route: '/',
	},
	{
		name: 'Readme',
		route: '/readme',
		childRoutes: [
			{
				name: 'What it is',
				route: '/readme#what-it-is',
			},
			{
				name: 'Features',
				route: '/readme#features',
			},
			{
				name: 'Component props',
				route: '/readme#component-properties',
				childRoutes: [
					{
						name: 'The routes array',
						route: '/readme#the-routes-array',
					},
					{
						name: 'The theme property',
						route: '/readme#the-theme-property',
					},
				],
			},
			{
				name: 'Slots',
				route: '/readme#slots',
			},
			{
				name: 'License',
				route: '/readme#license',
			},
			{
				name: 'Contribution',
				route: '/readme#contribution',
			},
		],
	},
	{
		name: 'Example group',
		route: '/another-link-group',
		childRoutes: [
			{
				name: 'A not disabled link',
				route: '/another-link-group/enabled',
			},
			{
				name: 'A disabled link',
				route: '/another-link-group/disabled',
				disabled: true,
			},
		],
		collapseTree: true,
	},
	{
		name: 'Disabled example group',
		route: '/disabled',
		disabled: true,
		childRoutes: [
			{
				name: 'Sub-link 1',
				route: '/disabled/sub-link-1',
			},
			{
				name: 'Sub-link 2',
				route: '/disabled/sub-link-2',
			},
		],
	},
];

[...exampleRoutes];

const exampleSidebarProps = Object.freeze({
	routes: exampleRoutes,
	open: window.innerWidth > 950,
	theme: {
		backgroundColor_linkActive: '#F4442E',
		backgroundColor_nav: isDarkMode ? '#1E1E1E' : '#003649',
		color_link: '#F7F7F2',
		color_linkHover: '#FCA311',
		fontSize: '1rem',
		maxWidth_nav: '20vw',
		minWidth_nav: '320px',
		opacity_linkDisabled: '0.5',
		opacity_linkInactive: '0.75',
	},
});

/* src/pages/playground/SidebarCodePreview.svelte generated by Svelte v3.47.0 */

const { Object: Object_1 } = globals;
const file$7 = "src/pages/playground/SidebarCodePreview.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (15:4) {#if JSON.stringify(prop[1]).split('\n').length > 1}
function create_if_block$5(ctx) {
	let br;

	const block = {
		c: function create() {
			br = element("br");
			add_location(br, file$7, 15, 5, 456);
		},
		m: function mount(target, anchor) {
			insert_dev(target, br, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(15:4) {#if JSON.stringify(prop[1]).split('\\n').length > 1}",
		ctx
	});

	return block;
}

// (10:1) {#each Object.entries(sidebarConfig) as prop (prop[0])}
function create_each_block(key_1, ctx) {
	let p;
	let span0;
	let t0_value = /*prop*/ ctx[2][0] + "";
	let t0;
	let t1;
	let span1;
	let t3;
	let span2;
	let show_if = JSON.stringify(/*prop*/ ctx[2][1]).split('\n').length > 1;
	let t4;
	let t5_value = JSON.stringify(/*prop*/ ctx[2][1], null, 4).replace(/^"|"$/gi, '') + "";
	let t5;
	let t6;
	let span3;
	let if_block = show_if && create_if_block$5(ctx);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			p = element("p");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = space();
			span1 = element("span");
			span1.textContent = "=\"";
			t3 = space();
			span2 = element("span");
			if (if_block) if_block.c();
			t4 = space();
			t5 = text(t5_value);
			t6 = space();
			span3 = element("span");
			span3.textContent = "\"";
			add_location(span0, file$7, 11, 3, 287);
			attr_dev(span1, "class", "control-character svelte-srkzqx");
			add_location(span1, file$7, 12, 3, 313);
			attr_dev(span2, "class", "component-prop-value svelte-srkzqx");
			add_location(span2, file$7, 13, 3, 358);
			attr_dev(span3, "class", "control-character svelte-srkzqx");
			add_location(span3, file$7, 19, 3, 549);
			attr_dev(p, "class", "component-prop svelte-srkzqx");
			add_location(p, file$7, 10, 2, 257);
			this.first = p;
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, span0);
			append_dev(span0, t0);
			append_dev(p, t1);
			append_dev(p, span1);
			append_dev(p, t3);
			append_dev(p, span2);
			if (if_block) if_block.m(span2, null);
			append_dev(span2, t4);
			append_dev(span2, t5);
			append_dev(p, t6);
			append_dev(p, span3);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*sidebarConfig*/ 1 && t0_value !== (t0_value = /*prop*/ ctx[2][0] + "")) set_data_dev(t0, t0_value);
			if (dirty & /*sidebarConfig*/ 1) show_if = JSON.stringify(/*prop*/ ctx[2][1]).split('\n').length > 1;

			if (show_if) {
				if (if_block) ; else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					if_block.m(span2, t4);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*sidebarConfig*/ 1 && t5_value !== (t5_value = JSON.stringify(/*prop*/ ctx[2][1], null, 4).replace(/^"|"$/gi, '') + "")) set_data_dev(t5, t5_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(10:1) {#each Object.entries(sidebarConfig) as prop (prop[0])}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let aside;
	let legend;
	let t1;
	let span0;
	let t3;
	let span1;
	let t5;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t6;
	let span2;
	let each_value = Object.entries(/*sidebarConfig*/ ctx[0]);
	validate_each_argument(each_value);
	const get_key = ctx => /*prop*/ ctx[2][0];
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			aside = element("aside");
			legend = element("legend");
			legend.textContent = "Result";
			t1 = space();
			span0 = element("span");
			span0.textContent = "<";
			t3 = space();
			span1 = element("span");
			span1.textContent = "Sidebar";
			t5 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t6 = space();
			span2 = element("span");
			span2.textContent = "/>";
			attr_dev(legend, "class", "svelte-srkzqx");
			add_location(legend, file$7, 6, 1, 90);
			attr_dev(span0, "class", "control-character svelte-srkzqx");
			add_location(span0, file$7, 7, 1, 115);
			attr_dev(span1, "class", "html-tag svelte-srkzqx");
			add_location(span1, file$7, 8, 1, 160);
			attr_dev(span2, "class", "control-character svelte-srkzqx");
			add_location(span2, file$7, 22, 1, 607);
			attr_dev(aside, "class", "svelte-srkzqx");
			toggle_class(aside, "dark", /*dark*/ ctx[1]);
			add_location(aside, file$7, 5, 0, 70);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, aside, anchor);
			append_dev(aside, legend);
			append_dev(aside, t1);
			append_dev(aside, span0);
			append_dev(aside, t3);
			append_dev(aside, span1);
			append_dev(aside, t5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(aside, null);
			}

			append_dev(aside, t6);
			append_dev(aside, span2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*JSON, Object, sidebarConfig*/ 1) {
				each_value = Object.entries(/*sidebarConfig*/ ctx[0]);
				validate_each_argument(each_value);
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, aside, destroy_block, create_each_block, t6, get_each_context);
			}

			if (dirty & /*dark*/ 2) {
				toggle_class(aside, "dark", /*dark*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(aside);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SidebarCodePreview', slots, []);
	let { sidebarConfig } = $$props;
	let { dark = null } = $$props;
	const writable_props = ['sidebarConfig', 'dark'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SidebarCodePreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('sidebarConfig' in $$props) $$invalidate(0, sidebarConfig = $$props.sidebarConfig);
		if ('dark' in $$props) $$invalidate(1, dark = $$props.dark);
	};

	$$self.$capture_state = () => ({ sidebarConfig, dark });

	$$self.$inject_state = $$props => {
		if ('sidebarConfig' in $$props) $$invalidate(0, sidebarConfig = $$props.sidebarConfig);
		if ('dark' in $$props) $$invalidate(1, dark = $$props.dark);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [sidebarConfig, dark];
}

class SidebarCodePreview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { sidebarConfig: 0, dark: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SidebarCodePreview",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*sidebarConfig*/ ctx[0] === undefined && !('sidebarConfig' in props)) {
			console.warn("<SidebarCodePreview> was created without expected prop 'sidebarConfig'");
		}
	}

	get sidebarConfig() {
		throw new Error("<SidebarCodePreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sidebarConfig(value) {
		throw new Error("<SidebarCodePreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dark() {
		throw new Error("<SidebarCodePreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dark(value) {
		throw new Error("<SidebarCodePreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Button.svelte generated by Svelte v3.47.0 */

const file$6 = "src/components/Button.svelte";

function create_fragment$6(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			button.disabled = /*disabled*/ ctx[1];
			attr_dev(button, "class", "svelte-7n524f");
			add_location(button, file$6, 5, 0, 69);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*onClick*/ ctx[0])) /*onClick*/ ctx[0].apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*disabled*/ 2) {
				prop_dev(button, "disabled", /*disabled*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Button', slots, ['default']);
	let { onClick } = $$props;
	let { disabled = false } = $$props;
	const writable_props = ['onClick', 'disabled'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('onClick' in $$props) $$invalidate(0, onClick = $$props.onClick);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ onClick, disabled });

	$$self.$inject_state = $$props => {
		if ('onClick' in $$props) $$invalidate(0, onClick = $$props.onClick);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [onClick, disabled, $$scope, slots];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { onClick: 0, disabled: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*onClick*/ ctx[0] === undefined && !('onClick' in props)) {
			console.warn("<Button> was created without expected prop 'onClick'");
		}
	}

	get onClick() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onClick(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/ColorInput.svelte generated by Svelte v3.47.0 */

const file$5 = "src/components/ColorInput.svelte";

// (8:1) {#if label}
function create_if_block$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(8:1) {#if label}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let label_1;
	let t;
	let input;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[2] && create_if_block$4(ctx);

	const block = {
		c: function create() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t = space();
			input = element("input");
			attr_dev(input, "type", "color");
			attr_dev(input, "id", /*id*/ ctx[1]);
			attr_dev(input, "class", "svelte-17wlbu5");
			add_location(input, file$5, 8, 1, 213);
			attr_dev(label_1, "for", /*id*/ ctx[1]);
			attr_dev(label_1, "class", "svelte-17wlbu5");
			add_location(label_1, file$5, 6, 0, 170);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append_dev(label_1, t);
			append_dev(label_1, input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[3]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					if_block.m(label_1, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*id*/ 2) {
				attr_dev(input, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty & /*id*/ 2) {
				attr_dev(label_1, "for", /*id*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(label_1);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ColorInput', slots, []);
	let { id = `color-input-${Math.random() * 100}` } = $$props; // To allow label to reference a unique color input.
	let { label = null } = $$props;
	let { value } = $$props;
	const writable_props = ['id', 'label', 'value'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ColorInput> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	$$self.$capture_state = () => ({ id, label, value });

	$$self.$inject_state = $$props => {
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [value, id, label, input_input_handler];
}

class ColorInput extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { id: 1, label: 2, value: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ColorInput",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
			console.warn("<ColorInput> was created without expected prop 'value'");
		}
	}

	get id() {
		throw new Error("<ColorInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<ColorInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<ColorInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<ColorInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<ColorInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<ColorInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/NumericInput.svelte generated by Svelte v3.47.0 */

const file$4 = "src/components/NumericInput.svelte";

// (12:1) {#if label}
function create_if_block$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(12:1) {#if label}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let label_1;
	let t;
	let input;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[2] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t = space();
			input = element("input");
			attr_dev(input, "id", /*id*/ ctx[1]);
			attr_dev(input, "type", "number");
			attr_dev(input, "min", /*min*/ ctx[3]);
			attr_dev(input, "max", /*max*/ ctx[4]);
			attr_dev(input, "step", /*step*/ ctx[5]);
			attr_dev(input, "class", "svelte-42yll1");
			toggle_class(input, "dark", /*dark*/ ctx[6]);
			add_location(input, file$4, 12, 1, 304);
			attr_dev(label_1, "for", /*id*/ ctx[1]);
			attr_dev(label_1, "class", "svelte-42yll1");
			add_location(label_1, file$4, 10, 0, 261);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append_dev(label_1, t);
			append_dev(label_1, input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[7]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(label_1, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*id*/ 2) {
				attr_dev(input, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*min*/ 8) {
				attr_dev(input, "min", /*min*/ ctx[3]);
			}

			if (dirty & /*max*/ 16) {
				attr_dev(input, "max", /*max*/ ctx[4]);
			}

			if (dirty & /*step*/ 32) {
				attr_dev(input, "step", /*step*/ ctx[5]);
			}

			if (dirty & /*value*/ 1 && to_number(input.value) !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty & /*dark*/ 64) {
				toggle_class(input, "dark", /*dark*/ ctx[6]);
			}

			if (dirty & /*id*/ 2) {
				attr_dev(label_1, "for", /*id*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(label_1);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('NumericInput', slots, []);
	let { id = `number-input-${Math.random() * 100}` } = $$props; // To allow label to reference a unique number input.
	let { label = null } = $$props;
	let { value } = $$props;
	let { min = 0.1 } = $$props;
	let { max = 1 } = $$props;
	let { step = 0.1 } = $$props;
	let { dark = null } = $$props;
	const writable_props = ['id', 'label', 'value', 'min', 'max', 'step', 'dark'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NumericInput> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		value = to_number(this.value);
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('min' in $$props) $$invalidate(3, min = $$props.min);
		if ('max' in $$props) $$invalidate(4, max = $$props.max);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
		if ('dark' in $$props) $$invalidate(6, dark = $$props.dark);
	};

	$$self.$capture_state = () => ({ id, label, value, min, max, step, dark });

	$$self.$inject_state = $$props => {
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('min' in $$props) $$invalidate(3, min = $$props.min);
		if ('max' in $$props) $$invalidate(4, max = $$props.max);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
		if ('dark' in $$props) $$invalidate(6, dark = $$props.dark);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [value, id, label, min, max, step, dark, input_input_handler];
}

class NumericInput extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			id: 1,
			label: 2,
			value: 0,
			min: 3,
			max: 4,
			step: 5,
			dark: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NumericInput",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
			console.warn("<NumericInput> was created without expected prop 'value'");
		}
	}

	get id() {
		throw new Error("<NumericInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<NumericInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<NumericInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<NumericInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<NumericInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<NumericInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<NumericInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<NumericInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<NumericInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<NumericInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<NumericInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<NumericInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dark() {
		throw new Error("<NumericInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dark(value) {
		throw new Error("<NumericInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Textarea.svelte generated by Svelte v3.47.0 */

const file$3 = "src/components/Textarea.svelte";

// (9:0) {#if label}
function create_if_block$2(ctx) {
	let label_1;
	let t;

	const block = {
		c: function create() {
			label_1 = element("label");
			t = text(/*label*/ ctx[2]);
			attr_dev(label_1, "for", /*id*/ ctx[1]);
			attr_dev(label_1, "class", "svelte-6lrjyz");
			add_location(label_1, file$3, 9, 1, 229);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			append_dev(label_1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);

			if (dirty & /*id*/ 2) {
				attr_dev(label_1, "for", /*id*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(9:0) {#if label}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let t;
	let textarea;
	let textarea_rows_value;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[2] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			textarea = element("textarea");
			attr_dev(textarea, "id", /*id*/ ctx[1]);
			textarea.required = /*required*/ ctx[3];
			attr_dev(textarea, "rows", textarea_rows_value = /*value*/ ctx[0].split('\n').length + 3);
			attr_dev(textarea, "class", "svelte-6lrjyz");
			toggle_class(textarea, "dark", /*dark*/ ctx[4]);
			add_location(textarea, file$3, 11, 0, 267);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, textarea, anchor);
			set_input_value(textarea, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*id*/ 2) {
				attr_dev(textarea, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*required*/ 8) {
				prop_dev(textarea, "required", /*required*/ ctx[3]);
			}

			if (dirty & /*value*/ 1 && textarea_rows_value !== (textarea_rows_value = /*value*/ ctx[0].split('\n').length + 3)) {
				attr_dev(textarea, "rows", textarea_rows_value);
			}

			if (dirty & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}

			if (dirty & /*dark*/ 16) {
				toggle_class(textarea, "dark", /*dark*/ ctx[4]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(textarea);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Textarea', slots, []);
	let { id = `textarea-${Math.random() * 100}` } = $$props; // To allow label to reference a unique textarea.
	let { label = null } = $$props;
	let { value } = $$props;
	let { required = true } = $$props;
	let { dark = null } = $$props;
	const writable_props = ['id', 'label', 'value', 'required', 'dark'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Textarea> was created with unknown prop '${key}'`);
	});

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('required' in $$props) $$invalidate(3, required = $$props.required);
		if ('dark' in $$props) $$invalidate(4, dark = $$props.dark);
	};

	$$self.$capture_state = () => ({ id, label, value, required, dark });

	$$self.$inject_state = $$props => {
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('required' in $$props) $$invalidate(3, required = $$props.required);
		if ('dark' in $$props) $$invalidate(4, dark = $$props.dark);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [value, id, label, required, dark, textarea_input_handler];
}

class Textarea extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			id: 1,
			label: 2,
			value: 0,
			required: 3,
			dark: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Textarea",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
			console.warn("<Textarea> was created without expected prop 'value'");
		}
	}

	get id() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dark() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dark(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const areObjectsEqual = (object1, object2) =>
	JSON.stringify(object1) !== JSON.stringify(object2);

const copyObjectDeep = (value) => JSON.parse(JSON.stringify(value));

const prettyPrintJson = (object) => JSON.stringify(object, null, 4);

/* src/pages/playground/Playground.svelte generated by Svelte v3.47.0 */

const { window: window_1$2 } = globals;
const file$2 = "src/pages/playground/Playground.svelte";

// (73:2) <Button onClick={resetSidebarConfig} disabled={!isConfigUnchanged}>
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("reset form");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(73:2) <Button onClick={resetSidebarConfig} disabled={!isConfigUnchanged}>",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let h2;
	let t1;
	let div5;
	let div1;
	let div0;
	let t3;
	let button;
	let t4;
	let fieldset0;
	let legend0;
	let t6;
	let div2;
	let colorinput0;
	let updating_value;
	let t7;
	let colorinput1;
	let updating_value_1;
	let t8;
	let colorinput2;
	let updating_value_2;
	let t9;
	let colorinput3;
	let updating_value_3;
	let t10;
	let fieldset1;
	let legend1;
	let t12;
	let div3;
	let numericinput0;
	let updating_value_4;
	let t13;
	let numericinput1;
	let updating_value_5;
	let t14;
	let fieldset2;
	let legend2;
	let t16;
	let div4;
	let numericinput2;
	let updating_value_6;
	let t17;
	let numericinput3;
	let updating_value_7;
	let t18;
	let numericinput4;
	let updating_value_8;
	let t19;
	let fieldset3;
	let legend3;
	let t21;
	let textarea;
	let updating_value_9;
	let t22;
	let sidebarcodepreview;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[6]);

	button = new Button({
			props: {
				onClick: /*resetSidebarConfig*/ ctx[5],
				disabled: !/*isConfigUnchanged*/ ctx[4],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	function colorinput0_value_binding(value) {
		/*colorinput0_value_binding*/ ctx[7](value);
	}

	let colorinput0_props = { label: "Background Color of Sidebar:" };

	if (/*sidebarConfig*/ ctx[0].theme.backgroundColor_nav !== void 0) {
		colorinput0_props.value = /*sidebarConfig*/ ctx[0].theme.backgroundColor_nav;
	}

	colorinput0 = new ColorInput({ props: colorinput0_props, $$inline: true });
	binding_callbacks.push(() => bind(colorinput0, 'value', colorinput0_value_binding));

	function colorinput1_value_binding(value) {
		/*colorinput1_value_binding*/ ctx[8](value);
	}

	let colorinput1_props = {
		label: "Background Color of Active Links:"
	};

	if (/*sidebarConfig*/ ctx[0].theme.backgroundColor_linkActive !== void 0) {
		colorinput1_props.value = /*sidebarConfig*/ ctx[0].theme.backgroundColor_linkActive;
	}

	colorinput1 = new ColorInput({ props: colorinput1_props, $$inline: true });
	binding_callbacks.push(() => bind(colorinput1, 'value', colorinput1_value_binding));

	function colorinput2_value_binding(value) {
		/*colorinput2_value_binding*/ ctx[9](value);
	}

	let colorinput2_props = { label: "Color of Link Text:" };

	if (/*sidebarConfig*/ ctx[0].theme.color_link !== void 0) {
		colorinput2_props.value = /*sidebarConfig*/ ctx[0].theme.color_link;
	}

	colorinput2 = new ColorInput({ props: colorinput2_props, $$inline: true });
	binding_callbacks.push(() => bind(colorinput2, 'value', colorinput2_value_binding));

	function colorinput3_value_binding(value) {
		/*colorinput3_value_binding*/ ctx[10](value);
	}

	let colorinput3_props = { label: "Hover Color of Link Text:" };

	if (/*sidebarConfig*/ ctx[0].theme.color_linkHover !== void 0) {
		colorinput3_props.value = /*sidebarConfig*/ ctx[0].theme.color_linkHover;
	}

	colorinput3 = new ColorInput({ props: colorinput3_props, $$inline: true });
	binding_callbacks.push(() => bind(colorinput3, 'value', colorinput3_value_binding));

	function numericinput0_value_binding(value) {
		/*numericinput0_value_binding*/ ctx[11](value);
	}

	let numericinput0_props = {
		label: "Opacity of Disabled Links:",
		dark: /*dark*/ ctx[1]
	};

	if (/*sidebarConfig*/ ctx[0].theme.opacity_linkDisabled !== void 0) {
		numericinput0_props.value = /*sidebarConfig*/ ctx[0].theme.opacity_linkDisabled;
	}

	numericinput0 = new NumericInput({
			props: numericinput0_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(numericinput0, 'value', numericinput0_value_binding));

	function numericinput1_value_binding(value) {
		/*numericinput1_value_binding*/ ctx[12](value);
	}

	let numericinput1_props = {
		label: "Opacity of Links Which Are Not Part of the Active Route:",
		dark: /*dark*/ ctx[1]
	};

	if (/*sidebarConfig*/ ctx[0].theme.opacity_linkInactive !== void 0) {
		numericinput1_props.value = /*sidebarConfig*/ ctx[0].theme.opacity_linkInactive;
	}

	numericinput1 = new NumericInput({
			props: numericinput1_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(numericinput1, 'value', numericinput1_value_binding));

	function numericinput2_value_binding(value) {
		/*numericinput2_value_binding*/ ctx[13](value);
	}

	let numericinput2_props = {
		label: "Font Size in rem:",
		dark: /*dark*/ ctx[1],
		max: "3"
	};

	if (/*playgroundConfig*/ ctx[3].fontSize !== void 0) {
		numericinput2_props.value = /*playgroundConfig*/ ctx[3].fontSize;
	}

	numericinput2 = new NumericInput({
			props: numericinput2_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(numericinput2, 'value', numericinput2_value_binding));

	function numericinput3_value_binding(value) {
		/*numericinput3_value_binding*/ ctx[14](value);
	}

	let numericinput3_props = {
		label: "Sidebar Maximum Width in px:",
		min: "10",
		step: "50",
		dark: /*dark*/ ctx[1],
		max: /*width*/ ctx[2]
	};

	if (/*playgroundConfig*/ ctx[3].maxWidth !== void 0) {
		numericinput3_props.value = /*playgroundConfig*/ ctx[3].maxWidth;
	}

	numericinput3 = new NumericInput({
			props: numericinput3_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(numericinput3, 'value', numericinput3_value_binding));

	function numericinput4_value_binding(value) {
		/*numericinput4_value_binding*/ ctx[15](value);
	}

	let numericinput4_props = {
		label: "Sidebar Minimum Width in px:",
		min: "0",
		step: "50",
		dark: /*dark*/ ctx[1],
		max: /*width*/ ctx[2]
	};

	if (/*playgroundConfig*/ ctx[3].minWidth !== void 0) {
		numericinput4_props.value = /*playgroundConfig*/ ctx[3].minWidth;
	}

	numericinput4 = new NumericInput({
			props: numericinput4_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(numericinput4, 'value', numericinput4_value_binding));

	function textarea_value_binding(value) {
		/*textarea_value_binding*/ ctx[16](value);
	}

	let textarea_props = {
		label: "Navigation Structure",
		dark: /*dark*/ ctx[1],
		required: true
	};

	if (/*playgroundConfig*/ ctx[3].routesFormatted !== void 0) {
		textarea_props.value = /*playgroundConfig*/ ctx[3].routesFormatted;
	}

	textarea = new Textarea({ props: textarea_props, $$inline: true });
	binding_callbacks.push(() => bind(textarea, 'value', textarea_value_binding));

	sidebarcodepreview = new SidebarCodePreview({
			props: {
				sidebarConfig: /*sidebarConfig*/ ctx[0],
				dark: /*dark*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			h2 = element("h2");
			h2.textContent = "Playground";
			t1 = space();
			div5 = element("div");
			div1 = element("div");
			div0 = element("div");
			div0.textContent = "Customise the sidebar on the left with the form below. The props\n\t\t\tpassed to the component can be seen on the right. Changes are\n\t\t\tdisplayed live.";
			t3 = space();
			create_component(button.$$.fragment);
			t4 = space();
			fieldset0 = element("fieldset");
			legend0 = element("legend");
			legend0.textContent = "Color";
			t6 = space();
			div2 = element("div");
			create_component(colorinput0.$$.fragment);
			t7 = space();
			create_component(colorinput1.$$.fragment);
			t8 = space();
			create_component(colorinput2.$$.fragment);
			t9 = space();
			create_component(colorinput3.$$.fragment);
			t10 = space();
			fieldset1 = element("fieldset");
			legend1 = element("legend");
			legend1.textContent = "Opacity";
			t12 = space();
			div3 = element("div");
			create_component(numericinput0.$$.fragment);
			t13 = space();
			create_component(numericinput1.$$.fragment);
			t14 = space();
			fieldset2 = element("fieldset");
			legend2 = element("legend");
			legend2.textContent = "Sizing";
			t16 = space();
			div4 = element("div");
			create_component(numericinput2.$$.fragment);
			t17 = space();
			create_component(numericinput3.$$.fragment);
			t18 = space();
			create_component(numericinput4.$$.fragment);
			t19 = space();
			fieldset3 = element("fieldset");
			legend3 = element("legend");
			legend3.textContent = "Routes";
			t21 = space();
			create_component(textarea.$$.fragment);
			t22 = space();
			create_component(sidebarcodepreview.$$.fragment);
			attr_dev(h2, "class", "heading svelte-2yjxf8");
			add_location(h2, file$2, 64, 0, 2233);
			add_location(div0, file$2, 67, 2, 2337);
			attr_dev(div1, "class", "form-explainer svelte-2yjxf8");
			add_location(div1, file$2, 66, 1, 2306);
			attr_dev(legend0, "class", "svelte-2yjxf8");
			add_location(legend0, file$2, 78, 2, 2623);
			attr_dev(div2, "class", "fieldset-container svelte-2yjxf8");
			add_location(div2, file$2, 85, 2, 2868);
			attr_dev(fieldset0, "class", "svelte-2yjxf8");
			add_location(fieldset0, file$2, 77, 1, 2610);
			attr_dev(legend1, "class", "svelte-2yjxf8");
			add_location(legend1, file$2, 109, 2, 3404);
			attr_dev(div3, "class", "fieldset-container svelte-2yjxf8");
			add_location(div3, file$2, 111, 2, 3432);
			attr_dev(fieldset1, "class", "svelte-2yjxf8");
			add_location(fieldset1, file$2, 108, 1, 3391);
			attr_dev(legend2, "class", "svelte-2yjxf8");
			add_location(legend2, file$2, 127, 2, 3795);
			attr_dev(div4, "class", "fieldset-container svelte-2yjxf8");
			add_location(div4, file$2, 129, 2, 3822);
			attr_dev(fieldset2, "class", "svelte-2yjxf8");
			add_location(fieldset2, file$2, 126, 1, 3782);
			attr_dev(legend3, "class", "svelte-2yjxf8");
			add_location(legend3, file$2, 158, 2, 4359);
			attr_dev(fieldset3, "class", "content-fieldset svelte-2yjxf8");
			add_location(fieldset3, file$2, 157, 1, 4321);
			attr_dev(div5, "class", "playground svelte-2yjxf8");
			toggle_class(div5, "dark", /*dark*/ ctx[1]);
			add_location(div5, file$2, 65, 0, 2269);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div5, anchor);
			append_dev(div5, div1);
			append_dev(div1, div0);
			append_dev(div1, t3);
			mount_component(button, div1, null);
			append_dev(div5, t4);
			append_dev(div5, fieldset0);
			append_dev(fieldset0, legend0);
			append_dev(fieldset0, t6);
			append_dev(fieldset0, div2);
			mount_component(colorinput0, div2, null);
			append_dev(div2, t7);
			mount_component(colorinput1, div2, null);
			append_dev(div2, t8);
			mount_component(colorinput2, div2, null);
			append_dev(div2, t9);
			mount_component(colorinput3, div2, null);
			append_dev(div5, t10);
			append_dev(div5, fieldset1);
			append_dev(fieldset1, legend1);
			append_dev(fieldset1, t12);
			append_dev(fieldset1, div3);
			mount_component(numericinput0, div3, null);
			append_dev(div3, t13);
			mount_component(numericinput1, div3, null);
			append_dev(div5, t14);
			append_dev(div5, fieldset2);
			append_dev(fieldset2, legend2);
			append_dev(fieldset2, t16);
			append_dev(fieldset2, div4);
			mount_component(numericinput2, div4, null);
			append_dev(div4, t17);
			mount_component(numericinput3, div4, null);
			append_dev(div4, t18);
			mount_component(numericinput4, div4, null);
			append_dev(div5, t19);
			append_dev(div5, fieldset3);
			append_dev(fieldset3, legend3);
			append_dev(fieldset3, t21);
			mount_component(textarea, fieldset3, null);
			insert_dev(target, t22, anchor);
			mount_component(sidebarcodepreview, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(window_1$2, "resize", /*onwindowresize*/ ctx[6]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};
			if (dirty & /*isConfigUnchanged*/ 16) button_changes.disabled = !/*isConfigUnchanged*/ ctx[4];

			if (dirty & /*$$scope*/ 131072) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const colorinput0_changes = {};

			if (!updating_value && dirty & /*sidebarConfig*/ 1) {
				updating_value = true;
				colorinput0_changes.value = /*sidebarConfig*/ ctx[0].theme.backgroundColor_nav;
				add_flush_callback(() => updating_value = false);
			}

			colorinput0.$set(colorinput0_changes);
			const colorinput1_changes = {};

			if (!updating_value_1 && dirty & /*sidebarConfig*/ 1) {
				updating_value_1 = true;
				colorinput1_changes.value = /*sidebarConfig*/ ctx[0].theme.backgroundColor_linkActive;
				add_flush_callback(() => updating_value_1 = false);
			}

			colorinput1.$set(colorinput1_changes);
			const colorinput2_changes = {};

			if (!updating_value_2 && dirty & /*sidebarConfig*/ 1) {
				updating_value_2 = true;
				colorinput2_changes.value = /*sidebarConfig*/ ctx[0].theme.color_link;
				add_flush_callback(() => updating_value_2 = false);
			}

			colorinput2.$set(colorinput2_changes);
			const colorinput3_changes = {};

			if (!updating_value_3 && dirty & /*sidebarConfig*/ 1) {
				updating_value_3 = true;
				colorinput3_changes.value = /*sidebarConfig*/ ctx[0].theme.color_linkHover;
				add_flush_callback(() => updating_value_3 = false);
			}

			colorinput3.$set(colorinput3_changes);
			const numericinput0_changes = {};
			if (dirty & /*dark*/ 2) numericinput0_changes.dark = /*dark*/ ctx[1];

			if (!updating_value_4 && dirty & /*sidebarConfig*/ 1) {
				updating_value_4 = true;
				numericinput0_changes.value = /*sidebarConfig*/ ctx[0].theme.opacity_linkDisabled;
				add_flush_callback(() => updating_value_4 = false);
			}

			numericinput0.$set(numericinput0_changes);
			const numericinput1_changes = {};
			if (dirty & /*dark*/ 2) numericinput1_changes.dark = /*dark*/ ctx[1];

			if (!updating_value_5 && dirty & /*sidebarConfig*/ 1) {
				updating_value_5 = true;
				numericinput1_changes.value = /*sidebarConfig*/ ctx[0].theme.opacity_linkInactive;
				add_flush_callback(() => updating_value_5 = false);
			}

			numericinput1.$set(numericinput1_changes);
			const numericinput2_changes = {};
			if (dirty & /*dark*/ 2) numericinput2_changes.dark = /*dark*/ ctx[1];

			if (!updating_value_6 && dirty & /*playgroundConfig*/ 8) {
				updating_value_6 = true;
				numericinput2_changes.value = /*playgroundConfig*/ ctx[3].fontSize;
				add_flush_callback(() => updating_value_6 = false);
			}

			numericinput2.$set(numericinput2_changes);
			const numericinput3_changes = {};
			if (dirty & /*dark*/ 2) numericinput3_changes.dark = /*dark*/ ctx[1];
			if (dirty & /*width*/ 4) numericinput3_changes.max = /*width*/ ctx[2];

			if (!updating_value_7 && dirty & /*playgroundConfig*/ 8) {
				updating_value_7 = true;
				numericinput3_changes.value = /*playgroundConfig*/ ctx[3].maxWidth;
				add_flush_callback(() => updating_value_7 = false);
			}

			numericinput3.$set(numericinput3_changes);
			const numericinput4_changes = {};
			if (dirty & /*dark*/ 2) numericinput4_changes.dark = /*dark*/ ctx[1];
			if (dirty & /*width*/ 4) numericinput4_changes.max = /*width*/ ctx[2];

			if (!updating_value_8 && dirty & /*playgroundConfig*/ 8) {
				updating_value_8 = true;
				numericinput4_changes.value = /*playgroundConfig*/ ctx[3].minWidth;
				add_flush_callback(() => updating_value_8 = false);
			}

			numericinput4.$set(numericinput4_changes);
			const textarea_changes = {};
			if (dirty & /*dark*/ 2) textarea_changes.dark = /*dark*/ ctx[1];

			if (!updating_value_9 && dirty & /*playgroundConfig*/ 8) {
				updating_value_9 = true;
				textarea_changes.value = /*playgroundConfig*/ ctx[3].routesFormatted;
				add_flush_callback(() => updating_value_9 = false);
			}

			textarea.$set(textarea_changes);

			if (dirty & /*dark*/ 2) {
				toggle_class(div5, "dark", /*dark*/ ctx[1]);
			}

			const sidebarcodepreview_changes = {};
			if (dirty & /*sidebarConfig*/ 1) sidebarcodepreview_changes.sidebarConfig = /*sidebarConfig*/ ctx[0];
			if (dirty & /*dark*/ 2) sidebarcodepreview_changes.dark = /*dark*/ ctx[1];
			sidebarcodepreview.$set(sidebarcodepreview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(colorinput0.$$.fragment, local);
			transition_in(colorinput1.$$.fragment, local);
			transition_in(colorinput2.$$.fragment, local);
			transition_in(colorinput3.$$.fragment, local);
			transition_in(numericinput0.$$.fragment, local);
			transition_in(numericinput1.$$.fragment, local);
			transition_in(numericinput2.$$.fragment, local);
			transition_in(numericinput3.$$.fragment, local);
			transition_in(numericinput4.$$.fragment, local);
			transition_in(textarea.$$.fragment, local);
			transition_in(sidebarcodepreview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(colorinput0.$$.fragment, local);
			transition_out(colorinput1.$$.fragment, local);
			transition_out(colorinput2.$$.fragment, local);
			transition_out(colorinput3.$$.fragment, local);
			transition_out(numericinput0.$$.fragment, local);
			transition_out(numericinput1.$$.fragment, local);
			transition_out(numericinput2.$$.fragment, local);
			transition_out(numericinput3.$$.fragment, local);
			transition_out(numericinput4.$$.fragment, local);
			transition_out(textarea.$$.fragment, local);
			transition_out(sidebarcodepreview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div5);
			destroy_component(button);
			destroy_component(colorinput0);
			destroy_component(colorinput1);
			destroy_component(colorinput2);
			destroy_component(colorinput3);
			destroy_component(numericinput0);
			destroy_component(numericinput1);
			destroy_component(numericinput2);
			destroy_component(numericinput3);
			destroy_component(numericinput4);
			destroy_component(textarea);
			if (detaching) detach_dev(t22);
			destroy_component(sidebarcodepreview, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Playground', slots, []);
	let { sidebarConfig } = $$props;
	let { dark } = $$props;
	let width;

	// Button to trigger `resetSidebarConfig` is disabled when there's nothing to reset.
	let isConfigUnchanged = false;

	/*
 * Contains the mutable configuration rendered on the playground below.
 * Counterintuitive: it's not possible to declare the let directly
 * from `initialSidebarProps`.
 */
	let playgroundConfig;

	const resetSidebarConfig = () => $$invalidate(0, sidebarConfig = { ...copyObjectDeep(exampleSidebarProps) });
	const writable_props = ['sidebarConfig', 'dark'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Playground> was created with unknown prop '${key}'`);
	});

	function onwindowresize() {
		$$invalidate(2, width = window_1$2.innerWidth);
	}

	function colorinput0_value_binding(value) {
		if ($$self.$$.not_equal(sidebarConfig.theme.backgroundColor_nav, value)) {
			sidebarConfig.theme.backgroundColor_nav = value;
			(($$invalidate(0, sidebarConfig), $$invalidate(2, width)), $$invalidate(3, playgroundConfig));
		}
	}

	function colorinput1_value_binding(value) {
		if ($$self.$$.not_equal(sidebarConfig.theme.backgroundColor_linkActive, value)) {
			sidebarConfig.theme.backgroundColor_linkActive = value;
			(($$invalidate(0, sidebarConfig), $$invalidate(2, width)), $$invalidate(3, playgroundConfig));
		}
	}

	function colorinput2_value_binding(value) {
		if ($$self.$$.not_equal(sidebarConfig.theme.color_link, value)) {
			sidebarConfig.theme.color_link = value;
			(($$invalidate(0, sidebarConfig), $$invalidate(2, width)), $$invalidate(3, playgroundConfig));
		}
	}

	function colorinput3_value_binding(value) {
		if ($$self.$$.not_equal(sidebarConfig.theme.color_linkHover, value)) {
			sidebarConfig.theme.color_linkHover = value;
			(($$invalidate(0, sidebarConfig), $$invalidate(2, width)), $$invalidate(3, playgroundConfig));
		}
	}

	function numericinput0_value_binding(value) {
		if ($$self.$$.not_equal(sidebarConfig.theme.opacity_linkDisabled, value)) {
			sidebarConfig.theme.opacity_linkDisabled = value;
			(($$invalidate(0, sidebarConfig), $$invalidate(2, width)), $$invalidate(3, playgroundConfig));
		}
	}

	function numericinput1_value_binding(value) {
		if ($$self.$$.not_equal(sidebarConfig.theme.opacity_linkInactive, value)) {
			sidebarConfig.theme.opacity_linkInactive = value;
			(($$invalidate(0, sidebarConfig), $$invalidate(2, width)), $$invalidate(3, playgroundConfig));
		}
	}

	function numericinput2_value_binding(value) {
		if ($$self.$$.not_equal(playgroundConfig.fontSize, value)) {
			playgroundConfig.fontSize = value;
			$$invalidate(3, playgroundConfig);
		}
	}

	function numericinput3_value_binding(value) {
		if ($$self.$$.not_equal(playgroundConfig.maxWidth, value)) {
			playgroundConfig.maxWidth = value;
			$$invalidate(3, playgroundConfig);
		}
	}

	function numericinput4_value_binding(value) {
		if ($$self.$$.not_equal(playgroundConfig.minWidth, value)) {
			playgroundConfig.minWidth = value;
			$$invalidate(3, playgroundConfig);
		}
	}

	function textarea_value_binding(value) {
		if ($$self.$$.not_equal(playgroundConfig.routesFormatted, value)) {
			playgroundConfig.routesFormatted = value;
			$$invalidate(3, playgroundConfig);
		}
	}

	$$self.$$set = $$props => {
		if ('sidebarConfig' in $$props) $$invalidate(0, sidebarConfig = $$props.sidebarConfig);
		if ('dark' in $$props) $$invalidate(1, dark = $$props.dark);
	};

	$$self.$capture_state = () => ({
		SidebarCodePreview,
		Button,
		ColorInput,
		NumericInput,
		Textarea,
		initialSidebarProps: exampleSidebarProps,
		areObjectsEqual,
		copyObjectDeep,
		prettyPrintJson,
		sidebarConfig,
		dark,
		width,
		isConfigUnchanged,
		playgroundConfig,
		resetSidebarConfig
	});

	$$self.$inject_state = $$props => {
		if ('sidebarConfig' in $$props) $$invalidate(0, sidebarConfig = $$props.sidebarConfig);
		if ('dark' in $$props) $$invalidate(1, dark = $$props.dark);
		if ('width' in $$props) $$invalidate(2, width = $$props.width);
		if ('isConfigUnchanged' in $$props) $$invalidate(4, isConfigUnchanged = $$props.isConfigUnchanged);
		if ('playgroundConfig' in $$props) $$invalidate(3, playgroundConfig = $$props.playgroundConfig);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*width, playgroundConfig*/ 12) {
			/*
 * Reactively translate the playground input to the format required by the
 * respective `Sidebar` property.
 */
			{
				// Close sidebar when the viewport is too small.
				$$invalidate(0, sidebarConfig.open = width > 950 && width / 3 > playgroundConfig.minWidth, sidebarConfig);

				// Translate numeric inputs to numeric values with unit.
				$$invalidate(0, sidebarConfig.theme.fontSize = `${playgroundConfig.fontSize}rem`, sidebarConfig);

				$$invalidate(0, sidebarConfig.theme.maxWidth_nav = `${playgroundConfig.maxWidth / width * 100}vw`, sidebarConfig);
				$$invalidate(0, sidebarConfig.theme.minWidth_nav = `${playgroundConfig.minWidth}px`, sidebarConfig);

				// Parse input from textarea back to JSON (and skip on failure).
				try {
					const parsedRoutes = JSON.parse(playgroundConfig.routesFormatted);
					$$invalidate(0, sidebarConfig.routes = parsedRoutes, sidebarConfig);
				} catch(e) {
					
				}
			}
		}

		if ($$self.$$.dirty & /*sidebarConfig*/ 1) {
			$$invalidate(4, isConfigUnchanged = areObjectsEqual(sidebarConfig, exampleSidebarProps));
		}
	};

	$$invalidate(3, playgroundConfig = {
		fontSize: parseFloat(exampleSidebarProps.theme.fontSize),
		maxWidth: parseFloat(exampleSidebarProps.theme.maxWidth_nav) / 100 * window.innerWidth,
		minWidth: parseFloat(exampleSidebarProps.theme.minWidth_nav),
		routesFormatted: prettyPrintJson(exampleSidebarProps.routes)
	});

	return [
		sidebarConfig,
		dark,
		width,
		playgroundConfig,
		isConfigUnchanged,
		resetSidebarConfig,
		onwindowresize,
		colorinput0_value_binding,
		colorinput1_value_binding,
		colorinput2_value_binding,
		colorinput3_value_binding,
		numericinput0_value_binding,
		numericinput1_value_binding,
		numericinput2_value_binding,
		numericinput3_value_binding,
		numericinput4_value_binding,
		textarea_value_binding
	];
}

class Playground extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { sidebarConfig: 0, dark: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Playground",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*sidebarConfig*/ ctx[0] === undefined && !('sidebarConfig' in props)) {
			console.warn("<Playground> was created without expected prop 'sidebarConfig'");
		}

		if (/*dark*/ ctx[1] === undefined && !('dark' in props)) {
			console.warn("<Playground> was created without expected prop 'dark'");
		}
	}

	get sidebarConfig() {
		throw new Error("<Playground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sidebarConfig(value) {
		throw new Error("<Playground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dark() {
		throw new Error("<Playground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dark(value) {
		throw new Error("<Playground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/documentation/Readme.svelte generated by Svelte v3.47.0 */

const { window: window_1$1 } = globals;
const file$1 = "src/pages/documentation/Readme.svelte";

// (87:0) {#if readme}
function create_if_block$1(ctx) {
	let article;
	let a;
	let t1;
	let html_tag;

	const block = {
		c: function create() {
			article = element("article");
			a = element("a");
			a.textContent = "GitHub";
			t1 = space();
			html_tag = new HtmlTag();
			attr_dev(a, "class", "github svelte-13wl37x");
			attr_dev(a, "href", "https://github.com/philipp-tailor/svelte_sidebar");
			attr_dev(a, "target", "_blank");
			add_location(a, file$1, 88, 2, 2329);
			html_tag.a = null;
			attr_dev(article, "class", "readme svelte-13wl37x");
			toggle_class(article, "dark", /*dark*/ ctx[0]);
			add_location(article, file$1, 87, 1, 2291);
		},
		m: function mount(target, anchor) {
			insert_dev(target, article, anchor);
			append_dev(article, a);
			append_dev(article, t1);
			html_tag.m(/*readme*/ ctx[1], article);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*readme*/ 2) html_tag.p(/*readme*/ ctx[1]);

			if (dirty & /*dark*/ 1) {
				toggle_class(article, "dark", /*dark*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(article);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(87:0) {#if readme}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*readme*/ ctx[1] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen_dev(window_1$1, "hashchange", /*scrollToHeading*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*readme*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Readme', slots, []);
	let { pathname } = $$props;
	let { dark } = $$props;
	let readme;
	let intersectionObserver;

	onMount(async () => {
		$$invalidate(1, { default: readme } = await import('./README.js'), readme);
		initHeadingIntersectionObserver();
	});

	// When the URL was changed through `Sidebar`, scroll to referenced heading.
	afterUpdate(() => {
		scrollToHeading();
	});

	onDestroy(() => {
		intersectionObserver && intersectionObserver.disconnect();
	});

	const initHeadingIntersectionObserver = () => {
		// Await DOM completion.
		setTimeout(
			() => {
				const headers = document.querySelectorAll('h2, h3, h4');

				const headerConfig = {
					/*
 * Watch for intersections in the top area of the screen.
 * If a heading is in the top stripe, it can be assumed that the
 * user is reading the paragraph, warranting a route update.
 */
					rootMargin: `0px 0px -${window.innerHeight - 50}px 0px`,
					threshold: 0.5
				};

				intersectionObserver = new IntersectionObserver(detectHeaderIntersection, headerConfig);
				headers.forEach(header => intersectionObserver.observe(header));
			},
			500
		);
	};

	/*
 * Add heading IDs to url hash when read. This has two benefits:
 * - The sidebar shows a correct active navigation link state.
 * - The user can pick up where he left on reload.
 */
	const detectHeaderIntersection = entries => {
		entries.forEach(entry => {
			if (entry.isIntersecting) {
				const element = entry.target;
				const headerName = element.id;
				const newUrl = `${window.location.pathname}#${headerName}`;
				history.replaceState({}, `Svelte Sidebar – ${headerName}`, newUrl);

				// Update route state in `App` (there's a prop binding).
				const newPathname = newUrl.replace(window.location.origin, '');

				$$invalidate(3, pathname = newPathname);
			}
		});
	};

	// Scroll to header referenced in URL hash (if existing).
	const scrollToHeading = () => {
		const urlHash = window.location.hash;

		if (urlHash) {
			const focusedHeader = document.getElementById(urlHash.replace('#', ''));
			focusedHeader && focusedHeader.scrollIntoView();
		}
	};

	const writable_props = ['pathname', 'dark'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Readme> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('pathname' in $$props) $$invalidate(3, pathname = $$props.pathname);
		if ('dark' in $$props) $$invalidate(0, dark = $$props.dark);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		onDestroy,
		onMount,
		pathname,
		dark,
		readme,
		intersectionObserver,
		initHeadingIntersectionObserver,
		detectHeaderIntersection,
		scrollToHeading
	});

	$$self.$inject_state = $$props => {
		if ('pathname' in $$props) $$invalidate(3, pathname = $$props.pathname);
		if ('dark' in $$props) $$invalidate(0, dark = $$props.dark);
		if ('readme' in $$props) $$invalidate(1, readme = $$props.readme);
		if ('intersectionObserver' in $$props) intersectionObserver = $$props.intersectionObserver;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [dark, readme, scrollToHeading, pathname];
}

class Readme extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { pathname: 3, dark: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Readme",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*pathname*/ ctx[3] === undefined && !('pathname' in props)) {
			console.warn("<Readme> was created without expected prop 'pathname'");
		}

		if (/*dark*/ ctx[0] === undefined && !('dark' in props)) {
			console.warn("<Readme> was created without expected prop 'dark'");
		}
	}

	get pathname() {
		throw new Error("<Readme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pathname(value) {
		throw new Error("<Readme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dark() {
		throw new Error("<Readme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dark(value) {
		throw new Error("<Readme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/App.svelte generated by Svelte v3.47.0 */

const { window: window_1 } = globals;
const file = "src/App.svelte";

// (60:1) 
function create_footer_slot(ctx) {
	let div;
	let themeswitcher;
	let updating_useDarkTheme;
	let current;

	function themeswitcher_useDarkTheme_binding(value) {
		/*themeswitcher_useDarkTheme_binding*/ ctx[6](value);
	}

	let themeswitcher_props = {};

	if (/*useDarkTheme*/ ctx[1] !== void 0) {
		themeswitcher_props.useDarkTheme = /*useDarkTheme*/ ctx[1];
	}

	themeswitcher = new ThemeSwitcher({
			props: themeswitcher_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(themeswitcher, 'useDarkTheme', themeswitcher_useDarkTheme_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(themeswitcher.$$.fragment);
			attr_dev(div, "class", "theme-switcher svelte-lcnjne");
			attr_dev(div, "slot", "footer");
			add_location(div, file, 59, 1, 1963);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(themeswitcher, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const themeswitcher_changes = {};

			if (!updating_useDarkTheme && dirty & /*useDarkTheme*/ 2) {
				updating_useDarkTheme = true;
				themeswitcher_changes.useDarkTheme = /*useDarkTheme*/ ctx[1];
				add_flush_callback(() => updating_useDarkTheme = false);
			}

			themeswitcher.$set(themeswitcher_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(themeswitcher.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(themeswitcher.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(themeswitcher);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(60:1) ",
		ctx
	});

	return block;
}

// (69:1) {:else}
function create_else_block(ctx) {
	let playground;
	let updating_sidebarConfig;
	let current;

	function playground_sidebarConfig_binding(value) {
		/*playground_sidebarConfig_binding*/ ctx[8](value);
	}

	let playground_props = { dark: /*useDarkTheme*/ ctx[1] };

	if (/*sidebarConfig*/ ctx[3] !== void 0) {
		playground_props.sidebarConfig = /*sidebarConfig*/ ctx[3];
	}

	playground = new Playground({ props: playground_props, $$inline: true });
	binding_callbacks.push(() => bind(playground, 'sidebarConfig', playground_sidebarConfig_binding));

	const block = {
		c: function create() {
			create_component(playground.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(playground, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const playground_changes = {};
			if (dirty & /*useDarkTheme*/ 2) playground_changes.dark = /*useDarkTheme*/ ctx[1];

			if (!updating_sidebarConfig && dirty & /*sidebarConfig*/ 8) {
				updating_sidebarConfig = true;
				playground_changes.sidebarConfig = /*sidebarConfig*/ ctx[3];
				add_flush_callback(() => updating_sidebarConfig = false);
			}

			playground.$set(playground_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(playground.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(playground.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(playground, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(69:1) {:else}",
		ctx
	});

	return block;
}

// (67:1) {#if pathname && pathname.includes('/readme')}
function create_if_block(ctx) {
	let readme;
	let updating_pathname;
	let current;

	function readme_pathname_binding(value) {
		/*readme_pathname_binding*/ ctx[7](value);
	}

	let readme_props = { dark: /*useDarkTheme*/ ctx[1] };

	if (/*pathname*/ ctx[0] !== void 0) {
		readme_props.pathname = /*pathname*/ ctx[0];
	}

	readme = new Readme({ props: readme_props, $$inline: true });
	binding_callbacks.push(() => bind(readme, 'pathname', readme_pathname_binding));

	const block = {
		c: function create() {
			create_component(readme.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(readme, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const readme_changes = {};
			if (dirty & /*useDarkTheme*/ 2) readme_changes.dark = /*useDarkTheme*/ ctx[1];

			if (!updating_pathname && dirty & /*pathname*/ 1) {
				updating_pathname = true;
				readme_changes.pathname = /*pathname*/ ctx[0];
				add_flush_callback(() => updating_pathname = false);
			}

			readme.$set(readme_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(readme.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(readme.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(readme, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(67:1) {#if pathname && pathname.includes('/readme')}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let switch_instance;
	let t;
	let main;
	let show_if;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const switch_instance_spread_levels = [/*sidebarConfig*/ ctx[3], { onLinkClick: /*onLinkClick*/ ctx[4] }];
	var switch_value = /*Sidebar*/ ctx[2];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { footer: [create_footer_slot] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*pathname*/ 1) show_if = null;
		if (show_if == null) show_if = !!(/*pathname*/ ctx[0] && /*pathname*/ ctx[0].includes('/readme'));
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			t = space();
			main = element("main");
			if_block.c();
			attr_dev(main, "class", "route-content svelte-lcnjne");
			toggle_class(main, "dark", /*useDarkTheme*/ ctx[1]);
			add_location(main, file, 64, 0, 2073);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, t, anchor);
			insert_dev(target, main, anchor);
			if_blocks[current_block_type_index].m(main, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(window_1, "popstate", /*popstate_handler*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*sidebarConfig, onLinkClick*/ 24)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*sidebarConfig*/ 8 && get_spread_object(/*sidebarConfig*/ ctx[3]),
					dirty & /*onLinkClick*/ 16 && { onLinkClick: /*onLinkClick*/ ctx[4] }
				])
			: {};

			if (dirty & /*$$scope, useDarkTheme*/ 1026) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*Sidebar*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, t.parentNode, t);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(main, null);
			}

			if (dirty & /*useDarkTheme*/ 2) {
				toggle_class(main, "dark", /*useDarkTheme*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (switch_instance) destroy_component(switch_instance, detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(main);
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('App', slots, []);
	let Sidebar;

	// Local state containing the active route in the app.
	let pathname = `${window.location.pathname}${window.location.hash}`;

	let useDarkTheme = null;

	onMount(() => {
		loadSidebar();
	});

	// Load `Sidebar` asynchronously to showcase  that it is a standalone module.
	const loadSidebar = async () => {
		const sidebarPath = './Sidebar.js';
		$$invalidate(2, { default: Sidebar } = await import(sidebarPath), Sidebar);
	};

	let sidebarConfig = {
		...copyObjectDeep(exampleSidebarProps),
		activeUrl: pathname
	};

	// Triggered when link is clicked in `Sidebar`
	const onLinkClick = event => {
		const { text: pageName, href } = event.target;

		// Build relative URL from clicked link's event target href attribute.
		const url = href.replace(window.location.origin, '');

		// Prevent standard navigation.
		event.preventDefault();

		// Push new route to browser history, update local routing state.
		history.pushState(null, `Svelte Sidebar - ${pageName}`, url);

		$$invalidate(0, pathname = url);
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
	});

	const popstate_handler = () => $$invalidate(0, pathname = window.location.pathname);

	function themeswitcher_useDarkTheme_binding(value) {
		useDarkTheme = value;
		$$invalidate(1, useDarkTheme);
	}

	function readme_pathname_binding(value) {
		pathname = value;
		$$invalidate(0, pathname);
	}

	function playground_sidebarConfig_binding(value) {
		sidebarConfig = value;
		(($$invalidate(3, sidebarConfig), $$invalidate(0, pathname)), $$invalidate(1, useDarkTheme));
	}

	$$self.$capture_state = () => ({
		onMount,
		ThemeSwitcher,
		initialSidebarProps: exampleSidebarProps,
		Playground,
		Readme,
		copyObjectDeep,
		Sidebar,
		pathname,
		useDarkTheme,
		loadSidebar,
		sidebarConfig,
		onLinkClick
	});

	$$self.$inject_state = $$props => {
		if ('Sidebar' in $$props) $$invalidate(2, Sidebar = $$props.Sidebar);
		if ('pathname' in $$props) $$invalidate(0, pathname = $$props.pathname);
		if ('useDarkTheme' in $$props) $$invalidate(1, useDarkTheme = $$props.useDarkTheme);
		if ('sidebarConfig' in $$props) $$invalidate(3, sidebarConfig = $$props.sidebarConfig);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*pathname*/ 1) {
			// Recompute `Sidebar`'s active URL prop whenver there's a route change.
			$$invalidate(3, sidebarConfig.activeUrl = pathname, sidebarConfig);
		}

		if ($$self.$$.dirty & /*useDarkTheme*/ 2) {
			// Render the sidebar with the fitting background color depending on chosen theme.
			$$invalidate(3, sidebarConfig.theme.backgroundColor_nav = useDarkTheme ? '#1E1E1E' : '#003649', sidebarConfig);
		}
	};

	return [
		pathname,
		useDarkTheme,
		Sidebar,
		sidebarConfig,
		onLinkClick,
		popstate_handler,
		themeswitcher_useDarkTheme_binding,
		readme_pathname_binding,
		playground_sidebarConfig_binding
	];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: create_fragment.name
		});
	}
}

const app = new App({
	target: document.body,
});

export { app as default };
//# sourceMappingURL=main.js.map
