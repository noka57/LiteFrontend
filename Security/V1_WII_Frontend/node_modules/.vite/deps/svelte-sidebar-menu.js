import {
  writable
} from "./chunk-WLRNH2NR.js";
import {
  blur,
  fade,
  fly,
  slide
} from "./chunk-YO7P3DV6.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onMount,
  run_all,
  safe_not_equal,
  set_data_dev,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots,
  validate_store
} from "./chunk-DOYNZ6DE.js";
import "./chunk-TWLJ45QX.js";

// node_modules/svelte-sidebar-menu/sidebarStore.js
var sidebarOpen = writable(false);
var sidebarIsInert = writable(true);
var sidebarStayOpen = writable(false);

// node_modules/svelte-sidebar-menu/Aside.svelte
var file = "node_modules/svelte-sidebar-menu/Aside.svelte";
function add_css(target) {
  append_styles(target, "svelte-yp3hav", ".close.svelte-yp3hav.svelte-yp3hav{left:-100%}.open.svelte-yp3hav.svelte-yp3hav{left:0}[inert].svelte-yp3hav.svelte-yp3hav{pointer-events:none;cursor:default}[inert].svelte-yp3hav.svelte-yp3hav,[inert].svelte-yp3hav .svelte-yp3hav{opacity:0.5;pointer-events:none;cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXNpZGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJzVkF1REUiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQXNpZGUuc3ZlbHRlIl19 */");
}
function create_if_block(ctx) {
  let aside;
  let aside_class_value;
  let aside_transition;
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  const block = {
    c: function create() {
      aside = element("aside");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", {
        class: true,
        "aria-hidden": true,
        inert: true
      });
      var aside_nodes = children(aside);
      if (default_slot)
        default_slot.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "class", aside_class_value = ctx[1] + " " + (ctx[6].class ? ctx[6].class : "") + " svelte-yp3hav");
      attr_dev(aside, "aria-hidden", ctx[4]);
      attr_dev(aside, "inert", ctx[2]);
      add_location(aside, file, 24, 1, 760);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (default_slot) {
        default_slot.m(aside, null);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[9],
            !current ? get_all_dirty_from_scope(ctx[9]) : get_slot_changes(default_slot_template, ctx[9], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 66 && aside_class_value !== (aside_class_value = ctx[1] + " " + (ctx[6].class ? ctx[6].class : "") + " svelte-yp3hav")) {
        attr_dev(aside, "class", aside_class_value);
      }
      if (!current || dirty & 4) {
        attr_dev(aside, "inert", ctx[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!aside_transition)
          aside_transition = create_bidirectional_transition(aside, ctx[5], ctx[0], true);
        aside_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (!aside_transition)
        aside_transition = create_bidirectional_transition(aside, ctx[5], ctx[0], false);
      aside_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && aside_transition)
        aside_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:0) {#if $sidebarOpen}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[3] && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $sidebarIsInert;
  let $sidebarOpen;
  validate_store(sidebarIsInert, "sidebarIsInert");
  component_subscribe($$self, sidebarIsInert, ($$value) => $$invalidate(8, $sidebarIsInert = $$value));
  validate_store(sidebarOpen, "sidebarOpen");
  component_subscribe($$self, sidebarOpen, ($$value) => $$invalidate(3, $sidebarOpen = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Aside", slots, ["default"]);
  let { transitionParams = {} } = $$props;
  let { transitionType = "fly" } = $$props;
  let { asideClass = "absolute w-auto h-screen bg-gray-200 border-r-2 shadow-lg" } = $$props;
  let inert = null;
  let ariaHidden;
  function multiple(node, params) {
    switch (transitionType) {
      case "slide":
        return slide(node, params);
      case "blur":
        return blur(node, params);
      case "fly":
        return fly(node, params);
      case "fade":
        return fade(node, params);
    }
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("transitionParams" in $$new_props)
      $$invalidate(0, transitionParams = $$new_props.transitionParams);
    if ("transitionType" in $$new_props)
      $$invalidate(7, transitionType = $$new_props.transitionType);
    if ("asideClass" in $$new_props)
      $$invalidate(1, asideClass = $$new_props.asideClass);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    sidebarOpen,
    sidebarIsInert,
    fly,
    slide,
    blur,
    fade,
    transitionParams,
    transitionType,
    asideClass,
    inert,
    ariaHidden,
    multiple,
    $sidebarIsInert,
    $sidebarOpen
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("transitionParams" in $$props)
      $$invalidate(0, transitionParams = $$new_props.transitionParams);
    if ("transitionType" in $$props)
      $$invalidate(7, transitionType = $$new_props.transitionType);
    if ("asideClass" in $$props)
      $$invalidate(1, asideClass = $$new_props.asideClass);
    if ("inert" in $$props)
      $$invalidate(2, inert = $$new_props.inert);
    if ("ariaHidden" in $$props)
      $$invalidate(4, ariaHidden = $$new_props.ariaHidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      $:
        $$invalidate(2, inert = $sidebarIsInert ? "inert" : null);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    transitionParams,
    asideClass,
    inert,
    $sidebarOpen,
    ariaHidden,
    multiple,
    $$props,
    transitionType,
    $sidebarIsInert,
    $$scope,
    slots
  ];
}
var Aside = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        transitionParams: 0,
        transitionType: 7,
        asideClass: 1
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Aside",
      options,
      id: create_fragment.name
    });
  }
  get transitionParams() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionParams(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionType() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionType(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asideClass() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asideClass(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Aside_default = Aside;

// node_modules/svelte-sidebar-menu/Nav.svelte
var file2 = "node_modules/svelte-sidebar-menu/Nav.svelte";
function create_fragment2(ctx) {
  let nav;
  let div;
  let nav_class_value;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  const block = {
    c: function create() {
      nav = element("nav");
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      div = claim_element(nav_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", ctx[1]);
      add_location(div, file2, 5, 1, 158);
      attr_dev(nav, "class", nav_class_value = ctx[0] + " " + (ctx[2].class ? ctx[2].class : ""));
      add_location(nav, file2, 4, 0, 95);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2) {
        attr_dev(div, "class", ctx2[1]);
      }
      if (!current || dirty & 5 && nav_class_value !== (nav_class_value = ctx2[0] + " " + (ctx2[2].class ? ctx2[2].class : ""))) {
        attr_dev(nav, "class", nav_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Nav", slots, ["default"]);
  let { navClass = "py-8 px-4 text-lg" } = $$props;
  let { navDivClass = "pb-8" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("navClass" in $$new_props)
      $$invalidate(0, navClass = $$new_props.navClass);
    if ("navDivClass" in $$new_props)
      $$invalidate(1, navDivClass = $$new_props.navDivClass);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ navClass, navDivClass });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    if ("navClass" in $$props)
      $$invalidate(0, navClass = $$new_props.navClass);
    if ("navDivClass" in $$props)
      $$invalidate(1, navDivClass = $$new_props.navDivClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [navClass, navDivClass, $$props, $$scope, slots];
}
var Nav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { navClass: 0, navDivClass: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav",
      options,
      id: create_fragment2.name
    });
  }
  get navClass() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navClass(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navDivClass() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navDivClass(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Nav_default = Nav;

// node_modules/svelte-sidebar-menu/inert.min.js
!function(e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t() : "function" == typeof define && define.amd ? define("inert", t) : t();
}(0, function() {
  "use strict";
  var u = function() {
    function i(e, t) {
      for (var n = 0; n < t.length; n++) {
        var i2 = t[n];
        i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e, i2.key, i2);
      }
    }
    return function(e, t, n) {
      return t && i(e.prototype, t), n && i(e, n), e;
    };
  }();
  function h(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  !function() {
    if ("undefined" != typeof window) {
      var o = Array.prototype.slice, r = Element.prototype.matches || Element.prototype.msMatchesSelector, i = [
        "a[href]",
        "area[href]",
        "input:not([disabled])",
        "select:not([disabled])",
        "textarea:not([disabled])",
        "button:not([disabled])",
        "details",
        "summary",
        "iframe",
        "object",
        "embed",
        "[contenteditable]"
      ].join(","), s = function() {
        function n(e2, t2) {
          h(this, n), this._inertManager = t2, this._rootElement = e2, this._managedNodes = /* @__PURE__ */ new Set(), this._rootElement.hasAttribute("aria-hidden") ? this._savedAriaHidden = this._rootElement.getAttribute("aria-hidden") : this._savedAriaHidden = null, this._rootElement.setAttribute("aria-hidden", "true"), this._makeSubtreeUnfocusable(this._rootElement), this._observer = new MutationObserver(this._onMutation.bind(this)), this._observer.observe(this._rootElement, {
            attributes: true,
            childList: true,
            subtree: true
          });
        }
        return u(n, [
          {
            key: "destructor",
            value: function() {
              this._observer.disconnect(), this._rootElement && (null !== this._savedAriaHidden ? this._rootElement.setAttribute("aria-hidden", this._savedAriaHidden) : this._rootElement.removeAttribute("aria-hidden")), this._managedNodes.forEach(function(e2) {
                this._unmanageNode(e2.node);
              }, this), this._observer = null, this._rootElement = null, this._managedNodes = null, this._inertManager = null;
            }
          },
          {
            key: "_makeSubtreeUnfocusable",
            value: function(e2) {
              var t2 = this;
              l(e2, function(e3) {
                return t2._visitNode(e3);
              });
              var n2 = document.activeElement;
              if (!document.body.contains(e2)) {
                for (var i2 = e2, o2 = void 0; i2; ) {
                  if (i2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    o2 = i2;
                    break;
                  }
                  i2 = i2.parentNode;
                }
                o2 && (n2 = o2.activeElement);
              }
              e2.contains(n2) && (n2.blur(), n2 === document.activeElement && document.body.focus());
            }
          },
          {
            key: "_visitNode",
            value: function(e2) {
              if (e2.nodeType === Node.ELEMENT_NODE) {
                var t2 = e2;
                t2 !== this._rootElement && t2.hasAttribute("inert") && this._adoptInertRoot(t2), (r.call(t2, i) || t2.hasAttribute("tabindex")) && this._manageNode(t2);
              }
            }
          },
          {
            key: "_manageNode",
            value: function(e2) {
              var t2 = this._inertManager.register(e2, this);
              this._managedNodes.add(t2);
            }
          },
          {
            key: "_unmanageNode",
            value: function(e2) {
              var t2 = this._inertManager.deregister(e2, this);
              t2 && this._managedNodes.delete(t2);
            }
          },
          {
            key: "_unmanageSubtree",
            value: function(e2) {
              var t2 = this;
              l(e2, function(e3) {
                return t2._unmanageNode(e3);
              });
            }
          },
          {
            key: "_adoptInertRoot",
            value: function(e2) {
              var t2 = this._inertManager.getInertRoot(e2);
              t2 || (this._inertManager.setInert(e2, true), t2 = this._inertManager.getInertRoot(e2)), t2.managedNodes.forEach(function(e3) {
                this._manageNode(e3.node);
              }, this);
            }
          },
          {
            key: "_onMutation",
            value: function(e2, t2) {
              e2.forEach(function(e3) {
                var t3 = e3.target;
                if ("childList" === e3.type)
                  o.call(e3.addedNodes).forEach(function(e4) {
                    this._makeSubtreeUnfocusable(e4);
                  }, this), o.call(e3.removedNodes).forEach(function(e4) {
                    this._unmanageSubtree(e4);
                  }, this);
                else if ("attributes" === e3.type) {
                  if ("tabindex" === e3.attributeName)
                    this._manageNode(t3);
                  else if (t3 !== this._rootElement && "inert" === e3.attributeName && t3.hasAttribute("inert")) {
                    this._adoptInertRoot(t3);
                    var n2 = this._inertManager.getInertRoot(t3);
                    this._managedNodes.forEach(function(e4) {
                      t3.contains(e4.node) && n2._manageNode(e4.node);
                    });
                  }
                }
              }, this);
            }
          },
          {
            key: "managedNodes",
            get: function() {
              return new Set(this._managedNodes);
            }
          },
          {
            key: "hasSavedAriaHidden",
            get: function() {
              return null !== this._savedAriaHidden;
            }
          },
          {
            key: "savedAriaHidden",
            set: function(e2) {
              this._savedAriaHidden = e2;
            },
            get: function() {
              return this._savedAriaHidden;
            }
          }
        ]), n;
      }(), a = function() {
        function n(e2, t2) {
          h(this, n), this._node = e2, this._overrodeFocusMethod = false, this._inertRoots = /* @__PURE__ */ new Set([t2]), this._savedTabIndex = null, this._destroyed = false, this.ensureUntabbable();
        }
        return u(n, [
          {
            key: "destructor",
            value: function() {
              if (this._throwIfDestroyed(), this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                var e2 = this._node;
                null !== this._savedTabIndex ? e2.setAttribute("tabindex", this._savedTabIndex) : e2.removeAttribute("tabindex"), this._overrodeFocusMethod && delete e2.focus;
              }
              this._node = null, this._inertRoots = null, this._destroyed = true;
            }
          },
          {
            key: "_throwIfDestroyed",
            value: function() {
              if (this.destroyed)
                throw new Error("Trying to access destroyed InertNode");
            }
          },
          {
            key: "ensureUntabbable",
            value: function() {
              if (this.node.nodeType === Node.ELEMENT_NODE) {
                var e2 = this.node;
                if (r.call(e2, i)) {
                  if (-1 === e2.tabIndex && this.hasSavedTabIndex)
                    return;
                  e2.hasAttribute("tabindex") && (this._savedTabIndex = e2.tabIndex), e2.setAttribute("tabindex", "-1"), e2.nodeType === Node.ELEMENT_NODE && (e2.focus = function() {
                  }, this._overrodeFocusMethod = true);
                } else
                  e2.hasAttribute("tabindex") && (this._savedTabIndex = e2.tabIndex, e2.removeAttribute("tabindex"));
              }
            }
          },
          {
            key: "addInertRoot",
            value: function(e2) {
              this._throwIfDestroyed(), this._inertRoots.add(e2);
            }
          },
          {
            key: "removeInertRoot",
            value: function(e2) {
              this._throwIfDestroyed(), this._inertRoots.delete(e2), 0 === this._inertRoots.size && this.destructor();
            }
          },
          {
            key: "destroyed",
            get: function() {
              return this._destroyed;
            }
          },
          {
            key: "hasSavedTabIndex",
            get: function() {
              return null !== this._savedTabIndex;
            }
          },
          {
            key: "node",
            get: function() {
              return this._throwIfDestroyed(), this._node;
            }
          },
          {
            key: "savedTabIndex",
            set: function(e2) {
              this._throwIfDestroyed(), this._savedTabIndex = e2;
            },
            get: function() {
              return this._throwIfDestroyed(), this._savedTabIndex;
            }
          }
        ]), n;
      }(), e = function() {
        function t2(e2) {
          if (h(this, t2), !e2)
            throw new Error("Missing required argument; InertManager needs to wrap a document.");
          this._document = e2, this._managedNodes = /* @__PURE__ */ new Map(), this._inertRoots = /* @__PURE__ */ new Map(), this._observer = new MutationObserver(this._watchForInert.bind(this)), d(e2.head || e2.body || e2.documentElement), "loading" === e2.readyState ? e2.addEventListener("DOMContentLoaded", this._onDocumentLoaded.bind(this)) : this._onDocumentLoaded();
        }
        return u(t2, [
          {
            key: "setInert",
            value: function(e2, t3) {
              if (t3) {
                if (this._inertRoots.has(e2))
                  return;
                var n = new s(e2, this);
                if (e2.setAttribute("inert", ""), this._inertRoots.set(e2, n), !this._document.body.contains(e2))
                  for (var i2 = e2.parentNode; i2; )
                    11 === i2.nodeType && d(i2), i2 = i2.parentNode;
              } else {
                if (!this._inertRoots.has(e2))
                  return;
                this._inertRoots.get(e2).destructor(), this._inertRoots.delete(e2), e2.removeAttribute("inert");
              }
            }
          },
          {
            key: "getInertRoot",
            value: function(e2) {
              return this._inertRoots.get(e2);
            }
          },
          {
            key: "register",
            value: function(e2, t3) {
              var n = this._managedNodes.get(e2);
              return void 0 !== n ? n.addInertRoot(t3) : n = new a(e2, t3), this._managedNodes.set(e2, n), n;
            }
          },
          {
            key: "deregister",
            value: function(e2, t3) {
              var n = this._managedNodes.get(e2);
              return n ? (n.removeInertRoot(t3), n.destroyed && this._managedNodes.delete(e2), n) : null;
            }
          },
          {
            key: "_onDocumentLoaded",
            value: function() {
              o.call(this._document.querySelectorAll("[inert]")).forEach(function(e2) {
                this.setInert(e2, true);
              }, this), this._observer.observe(this._document.body || this._document.documentElement, {
                attributes: true,
                subtree: true,
                childList: true
              });
            }
          },
          {
            key: "_watchForInert",
            value: function(e2, t3) {
              var i2 = this;
              e2.forEach(function(e3) {
                switch (e3.type) {
                  case "childList":
                    o.call(e3.addedNodes).forEach(function(e4) {
                      if (e4.nodeType === Node.ELEMENT_NODE) {
                        var t5 = o.call(e4.querySelectorAll("[inert]"));
                        r.call(e4, "[inert]") && t5.unshift(e4), t5.forEach(function(e5) {
                          this.setInert(e5, true);
                        }, i2);
                      }
                    }, i2);
                    break;
                  case "attributes":
                    if ("inert" !== e3.attributeName)
                      return;
                    var t4 = e3.target, n = t4.hasAttribute("inert");
                    i2.setInert(t4, n);
                }
              }, this);
            }
          }
        ]), t2;
      }();
      if (!Element.prototype.hasOwnProperty("inert")) {
        var t = new e(document);
        Object.defineProperty(Element.prototype, "inert", {
          enumerable: true,
          get: function() {
            return this.hasAttribute("inert");
          },
          set: function(e2) {
            t.setInert(this, e2);
          }
        });
      }
    }
    function l(e2, t2, n) {
      if (e2.nodeType == Node.ELEMENT_NODE) {
        var i2 = e2;
        t2 && t2(i2);
        var o2 = i2.shadowRoot;
        if (o2)
          return void l(o2, t2, o2);
        if ("content" == i2.localName) {
          for (var r2 = i2, s2 = r2.getDistributedNodes ? r2.getDistributedNodes() : [], a2 = 0; a2 < s2.length; a2++)
            l(s2[a2], t2, n);
          return;
        }
        if ("slot" == i2.localName) {
          for (var d2 = i2, u2 = d2.assignedNodes ? d2.assignedNodes({ flatten: true }) : [], h2 = 0; h2 < u2.length; h2++)
            l(u2[h2], t2, n);
          return;
        }
      }
      for (var c = e2.firstChild; null != c; )
        l(c, t2, n), c = c.nextSibling;
    }
    function d(e2) {
      if (!e2.querySelector("style#inert-style, link#inert-style")) {
        var t2 = document.createElement("style");
        t2.setAttribute("id", "inert-style"), t2.textContent = "\n[inert] {\n  pointer-events: none;\n  cursor: default;\n}\n\n[inert], [inert] * {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n", e2.appendChild(t2);
      }
    }
  }();
});

// node_modules/svelte-sidebar-menu/components/Hamburger.svelte
var file3 = "node_modules/svelte-sidebar-menu/components/Hamburger.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1prbcdr", "svg.svelte-1prbcdr.svelte-1prbcdr{min-height:24px;transition:transform 0.3s ease-in-out}svg.svelte-1prbcdr line.svelte-1prbcdr{stroke:currentColor;stroke-width:3;transition:transform 0.3s ease-in-out}button.svelte-1prbcdr.svelte-1prbcdr{z-index:20}.open.svelte-1prbcdr svg.svelte-1prbcdr{transform:scale(0.7)}.open.svelte-1prbcdr #top.svelte-1prbcdr{transform:translate(6px, 0px) rotate(45deg)}.open.svelte-1prbcdr #middle.svelte-1prbcdr{opacity:0}.open.svelte-1prbcdr #bottom.svelte-1prbcdr{transform:translate(-12px, 9px) rotate(-45deg)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGFtYnVyZ2VyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEwQkMsR0FBRyw4QkFBQyxDQUFBLEFBQ0gsVUFBVSxDQUFFLElBQUksQ0FDaEIsVUFBVSxDQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxBQUN2QyxDQUFBLEFBRUEsa0JBQUcsQ0FBQyxJQUFJLGVBQUMsQ0FBQSxBQUNSLE1BQU0sQ0FBRSxZQUFZLENBQ3BCLFlBQVksQ0FBRSxDQUFDLENBQ2YsVUFBVSxDQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxBQUN2QyxDQUFBLEFBRUEsTUFBTSw4QkFBQyxDQUFBLEFBQ04sT0FBTyxDQUFFLEVBQUUsQUFDWixDQUFBLEFBRUEsb0JBQUssQ0FBQyxHQUFHLGVBQUMsQ0FBQSxBQUNULFNBQVMsQ0FBRSxNQUFNLEdBQUcsQ0FBQyxBQUN0QixDQUFBLEFBRUEsb0JBQUssQ0FBQyxJQUFJLGVBQUMsQ0FBQSxBQUNWLFNBQVMsQ0FBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLEFBQzdDLENBQUEsQUFFQSxvQkFBSyxDQUFDLE9BQU8sZUFBQyxDQUFBLEFBQ2IsT0FBTyxDQUFFLENBQUMsQUFDWCxDQUFBLEFBRUEsb0JBQUssQ0FBQyxPQUFPLGVBQUMsQ0FBQSxBQUNiLFNBQVMsQ0FBRSxVQUFVLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLEFBQ2hELENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSGFtYnVyZ2VyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment3(ctx) {
  let button;
  let svg;
  let line0;
  let line1;
  let line2;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        id: true,
        class: true,
        "aria-label": true
      });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", { width: true, height: true, class: true });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        class: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        class: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        class: true
      });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "id", "top");
      attr_dev(line0, "x1", "0");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "32");
      attr_dev(line0, "y2", "2");
      attr_dev(line0, "class", "svelte-1prbcdr");
      add_location(line0, file3, 19, 2, 555);
      attr_dev(line1, "id", "middle");
      attr_dev(line1, "x1", "0");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "24");
      attr_dev(line1, "y2", "12");
      attr_dev(line1, "class", "svelte-1prbcdr");
      add_location(line1, file3, 20, 2, 604);
      attr_dev(line2, "id", "bottom");
      attr_dev(line2, "x1", "0");
      attr_dev(line2, "y1", "22");
      attr_dev(line2, "x2", "32");
      attr_dev(line2, "y2", "22");
      attr_dev(line2, "class", "svelte-1prbcdr");
      add_location(line2, file3, 21, 2, 658);
      attr_dev(svg, "width", "32");
      attr_dev(svg, "height", "24");
      attr_dev(svg, "class", "svelte-1prbcdr");
      add_location(svg, file3, 18, 1, 524);
      attr_dev(button, "id", "hamburgerBtn");
      attr_dev(button, "class", button_class_value = null_to_empty(ctx[0]) + " svelte-1prbcdr");
      attr_dev(button, "aria-label", "Sidebar");
      toggle_class(button, "open", ctx[1]);
      add_location(button, file3, 11, 0, 398);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[2], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1 && button_class_value !== (button_class_value = null_to_empty(ctx2[0]) + " svelte-1prbcdr")) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & 3) {
        toggle_class(button, "open", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $sidebarOpen;
  validate_store(sidebarOpen, "sidebarOpen");
  component_subscribe($$self, sidebarOpen, ($$value) => $$invalidate(1, $sidebarOpen = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Hamburger", slots, []);
  const toggleSide = () => {
    sidebarOpen.update((n) => n = !n);
    sidebarIsInert.update((n) => n = !n);
  };
  let { hamburgerClass = "" } = $$props;
  const writable_props = ["hamburgerClass"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Hamburger> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("hamburgerClass" in $$props2)
      $$invalidate(0, hamburgerClass = $$props2.hamburgerClass);
  };
  $$self.$capture_state = () => ({
    sidebarOpen,
    sidebarIsInert,
    sidebarStayOpen,
    toggleSide,
    hamburgerClass,
    $sidebarOpen
  });
  $$self.$inject_state = ($$props2) => {
    if ("hamburgerClass" in $$props2)
      $$invalidate(0, hamburgerClass = $$props2.hamburgerClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [hamburgerClass, $sidebarOpen, toggleSide];
}
var Hamburger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { hamburgerClass: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Hamburger",
      options,
      id: create_fragment3.name
    });
  }
  get hamburgerClass() {
    throw new Error("<Hamburger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hamburgerClass(value) {
    throw new Error("<Hamburger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Hamburger_default = Hamburger;

// node_modules/svelte-sidebar-menu/Navbar.svelte
var file4 = "node_modules/svelte-sidebar-menu/Navbar.svelte";
function create_fragment4(ctx) {
  let header;
  let nav;
  let hamburger;
  let t0;
  let div;
  let a;
  let img;
  let img_src_value;
  let t1;
  let span;
  let t2;
  let t3;
  let header_class_value;
  let current;
  hamburger = new Hamburger_default({
    props: {
      hamburgerClass: ctx[1]
    },
    $$inline: true
  });
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  const block = {
    c: function create() {
      header = element("header");
      nav = element("nav");
      create_component(hamburger.$$.fragment);
      t0 = space();
      div = element("div");
      a = element("a");
      img = element("img");
      t1 = space();
      span = element("span");
      t2 = text(ctx[7]);
      t3 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      nav = claim_element(header_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      claim_component(hamburger.$$.fragment, nav_nodes);
      t0 = claim_space(nav_nodes);
      div = claim_element(nav_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      img = claim_element(a_nodes, "IMG", { src: true, alt: true, class: true });
      t1 = claim_space(a_nodes);
      span = claim_element(a_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t2 = claim_text(span_nodes, ctx[7]);
      span_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      t3 = claim_space(nav_nodes);
      if (default_slot)
        default_slot.l(nav_nodes);
      nav_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = ctx[3]))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", ctx[0]);
      attr_dev(img, "class", ctx[4]);
      add_location(img, file4, 17, 4, 744);
      attr_dev(span, "class", ctx[8]);
      add_location(span, file4, 18, 4, 791);
      attr_dev(a, "href", "/");
      attr_dev(a, "class", "flex");
      add_location(a, file4, 16, 3, 714);
      attr_dev(div, "class", ctx[6]);
      add_location(div, file4, 15, 2, 687);
      attr_dev(nav, "class", ctx[5]);
      add_location(nav, file4, 13, 1, 629);
      attr_dev(header, "class", header_class_value = ctx[2] + " " + (ctx[9].class ? ctx[9].class : ""));
      add_location(header, file4, 12, 0, 560);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      append_hydration_dev(header, nav);
      mount_component(hamburger, nav, null);
      append_hydration_dev(nav, t0);
      append_hydration_dev(nav, div);
      append_hydration_dev(div, a);
      append_hydration_dev(a, img);
      append_hydration_dev(a, t1);
      append_hydration_dev(a, span);
      append_hydration_dev(span, t2);
      append_hydration_dev(nav, t3);
      if (default_slot) {
        default_slot.m(nav, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hamburger_changes = {};
      if (dirty & 2)
        hamburger_changes.hamburgerClass = ctx2[1];
      hamburger.$set(hamburger_changes);
      if (!current || dirty & 8 && !src_url_equal(img.src, img_src_value = ctx2[3])) {
        attr_dev(img, "src", img_src_value);
      }
      if (!current || dirty & 1) {
        attr_dev(img, "alt", ctx2[0]);
      }
      if (!current || dirty & 16) {
        attr_dev(img, "class", ctx2[4]);
      }
      if (!current || dirty & 128)
        set_data_dev(t2, ctx2[7]);
      if (!current || dirty & 256) {
        attr_dev(span, "class", ctx2[8]);
      }
      if (!current || dirty & 64) {
        attr_dev(div, "class", ctx2[6]);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32) {
        attr_dev(nav, "class", ctx2[5]);
      }
      if (!current || dirty & 516 && header_class_value !== (header_class_value = ctx2[2] + " " + (ctx2[9].class ? ctx2[9].class : ""))) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hamburger.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hamburger.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      destroy_component(hamburger);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Navbar", slots, ["default"]);
  let { alt = "" } = $$props;
  let { hamburgerClass = "text-gray-500 hover:text-gray-700 cursor-pointer mr-4 border-none focus:outline-none" } = $$props;
  let { headerClass = "bg-gray-200 pt-4 px-10 items-center text-gray-600" } = $$props;
  let { logo = "" } = $$props;
  let { logoClass = "" } = $$props;
  let { navClass = "flex relative" } = $$props;
  let { siteClass = "w-1/4 h-12 text-lg pt-1 pl-12" } = $$props;
  let { siteName = "Demo" } = $$props;
  let { spanClass = "pl-2 self-center text-lg font-semibold text-gray-900 whitespace-nowrap" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("alt" in $$new_props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("hamburgerClass" in $$new_props)
      $$invalidate(1, hamburgerClass = $$new_props.hamburgerClass);
    if ("headerClass" in $$new_props)
      $$invalidate(2, headerClass = $$new_props.headerClass);
    if ("logo" in $$new_props)
      $$invalidate(3, logo = $$new_props.logo);
    if ("logoClass" in $$new_props)
      $$invalidate(4, logoClass = $$new_props.logoClass);
    if ("navClass" in $$new_props)
      $$invalidate(5, navClass = $$new_props.navClass);
    if ("siteClass" in $$new_props)
      $$invalidate(6, siteClass = $$new_props.siteClass);
    if ("siteName" in $$new_props)
      $$invalidate(7, siteName = $$new_props.siteName);
    if ("spanClass" in $$new_props)
      $$invalidate(8, spanClass = $$new_props.spanClass);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Hamburger: Hamburger_default,
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navClass,
    siteClass,
    siteName,
    spanClass
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("alt" in $$props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("hamburgerClass" in $$props)
      $$invalidate(1, hamburgerClass = $$new_props.hamburgerClass);
    if ("headerClass" in $$props)
      $$invalidate(2, headerClass = $$new_props.headerClass);
    if ("logo" in $$props)
      $$invalidate(3, logo = $$new_props.logo);
    if ("logoClass" in $$props)
      $$invalidate(4, logoClass = $$new_props.logoClass);
    if ("navClass" in $$props)
      $$invalidate(5, navClass = $$new_props.navClass);
    if ("siteClass" in $$props)
      $$invalidate(6, siteClass = $$new_props.siteClass);
    if ("siteName" in $$props)
      $$invalidate(7, siteName = $$new_props.siteName);
    if ("spanClass" in $$props)
      $$invalidate(8, spanClass = $$new_props.spanClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navClass,
    siteClass,
    siteName,
    spanClass,
    $$props,
    $$scope,
    slots
  ];
}
var Navbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      alt: 0,
      hamburgerClass: 1,
      headerClass: 2,
      logo: 3,
      logoClass: 4,
      navClass: 5,
      siteClass: 6,
      siteName: 7,
      spanClass: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navbar",
      options,
      id: create_fragment4.name
    });
  }
  get alt() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hamburgerClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hamburgerClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logo() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logo(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logoClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logoClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteName() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteName(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spanClass() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spanClass(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Navbar_default = Navbar;

// node_modules/svelte-sidebar-menu/Responsive.svelte
function create_fragment5(ctx) {
  let mounted;
  let dispose;
  add_render_callback(ctx[2]);
  const block = {
    c: noop,
    l: noop,
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = listen_dev(window, "resize", ctx[2]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Responsive", slots, []);
  let { breakPoint = 1024 } = $$props;
  let width;
  onMount(() => {
    if (width >= breakPoint) {
      sidebarStayOpen.update((n) => n = true);
      sidebarOpen.update((n) => n = true);
      sidebarIsInert.update((n) => n = false);
    } else {
      sidebarStayOpen.update((n) => n = false);
      sidebarOpen.update((n) => n = false);
      sidebarIsInert.update((n) => n = true);
    }
  });
  const writable_props = ["breakPoint"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Responsive> was created with unknown prop '${key}'`);
  });
  function onwindowresize() {
    $$invalidate(0, width = window.innerWidth);
  }
  $$self.$$set = ($$props2) => {
    if ("breakPoint" in $$props2)
      $$invalidate(1, breakPoint = $$props2.breakPoint);
  };
  $$self.$capture_state = () => ({
    sidebarOpen,
    sidebarIsInert,
    sidebarStayOpen,
    onMount,
    breakPoint,
    width
  });
  $$self.$inject_state = ($$props2) => {
    if ("breakPoint" in $$props2)
      $$invalidate(1, breakPoint = $$props2.breakPoint);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $:
        if (width >= breakPoint) {
          sidebarStayOpen.update((n) => n = true);
          sidebarOpen.update((n) => n = true);
          sidebarIsInert.update((n) => n = false);
        } else {
          sidebarStayOpen.update((n) => n = false);
          sidebarOpen.update((n) => n = false);
          sidebarIsInert.update((n) => n = true);
        }
    }
  };
  return [width, breakPoint, onwindowresize];
}
var Responsive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { breakPoint: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Responsive",
      options,
      id: create_fragment5.name
    });
  }
  get breakPoint() {
    throw new Error("<Responsive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set breakPoint(value) {
    throw new Error("<Responsive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Responsive_default = Responsive;

// node_modules/svelte-sidebar-menu/Sidebar.svelte
var file5 = "node_modules/svelte-sidebar-menu/Sidebar.svelte";
function add_css3(target) {
  append_styles(target, "svelte-abvx89", ".close.svelte-abvx89.svelte-abvx89{left:-100%}.open.svelte-abvx89.svelte-abvx89{left:0}[inert].svelte-abvx89.svelte-abvx89{pointer-events:none;cursor:default}[inert].svelte-abvx89.svelte-abvx89,[inert].svelte-abvx89 .svelte-abvx89{opacity:0.5;pointer-events:none;cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2lkZWJhci5zdmVsdGUiLCJtYXBwaW5ncyI6InNWQStIRSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTaWRlYmFyLnN2ZWx0ZSJdfQ== */");
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i].href;
  child_ctx[24] = list[i].name;
  child_ctx[25] = list[i].rel;
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i].href;
  child_ctx[24] = list[i].name;
  child_ctx[25] = list[i].rel;
  return child_ctx;
}
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = ctx[21].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[22], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(default_slot_template, ctx2[22], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(57:1) <Navbar   {alt}   {hamburgerClass}   {headerClass}   {logo}   {logoClass}   navClass={navBarClass}   {siteClass}   {siteName}   {spanClass}  >",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let aside;
  let nav;
  let div;
  let div_class_value;
  let nav_class_value;
  let aside_class_value;
  let current;
  let each_value_1 = ctx[0];
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      aside = element("aside");
      nav = element("nav");
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", {
        class: true,
        "aria-hidden": true,
        inert: true
      });
      var aside_nodes = children(aside);
      nav = claim_element(aside_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      div = claim_element(nav_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(ctx[12]) + " svelte-abvx89");
      add_location(div, file5, 95, 4, 2542);
      attr_dev(nav, "class", nav_class_value = null_to_empty(ctx[10]) + " svelte-abvx89");
      add_location(nav, file5, 94, 3, 2515);
      attr_dev(aside, "class", aside_class_value = null_to_empty(ctx[11]) + " svelte-abvx89");
      attr_dev(aside, "aria-hidden", ctx[18]);
      attr_dev(aside, "inert", ctx[16]);
      toggle_class(aside, "open", ctx[17]);
      toggle_class(aside, "close", !ctx[17]);
      add_location(aside, file5, 87, 2, 2378);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      append_hydration_dev(aside, nav);
      append_hydration_dev(nav, div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8193) {
        each_value_1 = ctx2[0];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 4096 && div_class_value !== (div_class_value = null_to_empty(ctx2[12]) + " svelte-abvx89")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 1024 && nav_class_value !== (nav_class_value = null_to_empty(ctx2[10]) + " svelte-abvx89")) {
        attr_dev(nav, "class", nav_class_value);
      }
      if (!current || dirty & 2048 && aside_class_value !== (aside_class_value = null_to_empty(ctx2[11]) + " svelte-abvx89")) {
        attr_dev(aside, "class", aside_class_value);
      }
      if (!current || dirty & 262144) {
        attr_dev(aside, "aria-hidden", ctx2[18]);
      }
      if (!current || dirty & 65536) {
        attr_dev(aside, "inert", ctx2[16]);
      }
      if (!current || dirty & 133120) {
        toggle_class(aside, "open", ctx2[17]);
      }
      if (!current || dirty & 133120) {
        toggle_class(aside, "close", !ctx2[17]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(87:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[17] && create_if_block_1(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[17]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 131072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(70:1) {#if transitionType}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let sidebarlist;
  let current;
  sidebarlist = new SidebarList_default({
    props: {
      href: ctx[23],
      name: ctx[24],
      rel: ctx[25],
      sideBarListClass: ctx[13]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(sidebarlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(sidebarlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(sidebarlist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const sidebarlist_changes = {};
      if (dirty & 1)
        sidebarlist_changes.href = ctx2[23];
      if (dirty & 1)
        sidebarlist_changes.name = ctx2[24];
      if (dirty & 1)
        sidebarlist_changes.rel = ctx2[25];
      if (dirty & 8192)
        sidebarlist_changes.sideBarListClass = ctx2[13];
      sidebarlist.$set(sidebarlist_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(sidebarlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(97:5) {#each lists as { href, name, rel }}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let aside;
  let nav;
  let div;
  let div_class_value;
  let nav_class_value;
  let aside_class_value;
  let aside_transition;
  let current;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      aside = element("aside");
      nav = element("nav");
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", {
        class: true,
        "aria-hidden": true,
        inert: true
      });
      var aside_nodes = children(aside);
      nav = claim_element(aside_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      div = claim_element(nav_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(ctx[12]) + " svelte-abvx89");
      add_location(div, file5, 78, 5, 2179);
      attr_dev(nav, "class", nav_class_value = null_to_empty(ctx[10]) + " svelte-abvx89");
      add_location(nav, file5, 77, 4, 2151);
      attr_dev(aside, "class", aside_class_value = null_to_empty(ctx[11]) + " svelte-abvx89");
      attr_dev(aside, "aria-hidden", ctx[18]);
      attr_dev(aside, "inert", ctx[16]);
      add_location(aside, file5, 71, 3, 2028);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      append_hydration_dev(aside, nav);
      append_hydration_dev(nav, div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8193) {
        each_value = ctx[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 4096 && div_class_value !== (div_class_value = null_to_empty(ctx[12]) + " svelte-abvx89")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 1024 && nav_class_value !== (nav_class_value = null_to_empty(ctx[10]) + " svelte-abvx89")) {
        attr_dev(nav, "class", nav_class_value);
      }
      if (!current || dirty & 2048 && aside_class_value !== (aside_class_value = null_to_empty(ctx[11]) + " svelte-abvx89")) {
        attr_dev(aside, "class", aside_class_value);
      }
      if (!current || dirty & 262144) {
        attr_dev(aside, "aria-hidden", ctx[18]);
      }
      if (!current || dirty & 65536) {
        attr_dev(aside, "inert", ctx[16]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      add_render_callback(() => {
        if (!aside_transition)
          aside_transition = create_bidirectional_transition(aside, ctx[19], ctx[14], true);
        aside_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      if (!aside_transition)
        aside_transition = create_bidirectional_transition(aside, ctx[19], ctx[14], false);
      aside_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      destroy_each(each_blocks, detaching);
      if (detaching && aside_transition)
        aside_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(71:2) {#if sidebarStatus}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let sidebarlist;
  let current;
  sidebarlist = new SidebarList_default({
    props: {
      href: ctx[23],
      name: ctx[24],
      rel: ctx[25],
      sideBarListClass: ctx[13]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(sidebarlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(sidebarlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(sidebarlist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const sidebarlist_changes = {};
      if (dirty & 1)
        sidebarlist_changes.href = ctx2[23];
      if (dirty & 1)
        sidebarlist_changes.name = ctx2[24];
      if (dirty & 1)
        sidebarlist_changes.rel = ctx2[25];
      if (dirty & 8192)
        sidebarlist_changes.sideBarListClass = ctx2[13];
      sidebarlist.$set(sidebarlist_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(sidebarlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(80:6) {#each lists as { href, name, rel }}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let navbar;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  navbar = new Navbar_default({
    props: {
      alt: ctx[1],
      hamburgerClass: ctx[2],
      headerClass: ctx[3],
      logo: ctx[4],
      logoClass: ctx[5],
      navClass: ctx[6],
      siteClass: ctx[8],
      siteName: ctx[7],
      spanClass: ctx[9],
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[15])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      create_component(navbar.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(navbar.$$.fragment, nodes);
      t = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(navbar, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navbar_changes = {};
      if (dirty & 2)
        navbar_changes.alt = ctx2[1];
      if (dirty & 4)
        navbar_changes.hamburgerClass = ctx2[2];
      if (dirty & 8)
        navbar_changes.headerClass = ctx2[3];
      if (dirty & 16)
        navbar_changes.logo = ctx2[4];
      if (dirty & 32)
        navbar_changes.logoClass = ctx2[5];
      if (dirty & 64)
        navbar_changes.navClass = ctx2[6];
      if (dirty & 256)
        navbar_changes.siteClass = ctx2[8];
      if (dirty & 128)
        navbar_changes.siteName = ctx2[7];
      if (dirty & 512)
        navbar_changes.spanClass = ctx2[9];
      if (dirty & 4194304) {
        navbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navbar.$set(navbar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navbar.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(navbar.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navbar, detaching);
      if (detaching)
        detach_dev(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(56:0) <OutsideClick>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let outsideclick;
  let current;
  outsideclick = new OutsideClick_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(outsideclick.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(outsideclick.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(outsideclick, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const outsideclick_changes = {};
      if (dirty & 4718591) {
        outsideclick_changes.$$scope = { dirty, ctx: ctx2 };
      }
      outsideclick.$set(outsideclick_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(outsideclick.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(outsideclick.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(outsideclick, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $sidebarIsInert;
  validate_store(sidebarIsInert, "sidebarIsInert");
  component_subscribe($$self, sidebarIsInert, ($$value) => $$invalidate(20, $sidebarIsInert = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Sidebar", slots, ["default"]);
  let { lists } = $$props;
  let { alt = "" } = $$props;
  let { hamburgerClass = "" } = $$props;
  let { headerClass = "bg-gray-200 pt-4 px-10 items-center text-gray-600" } = $$props;
  let { logo = "" } = $$props;
  let { logoClass = "" } = $$props;
  let { navBarClass = "flex relative" } = $$props;
  let { siteName = "Demo" } = $$props;
  let { siteClass = "w-1/4 h-12 text-lg pt-1 pl-12" } = $$props;
  let { spanClass = "pl-2 self-center text-lg font-semibold text-gray-900 whitespace-nowrap" } = $$props;
  let { navClass = "py-8 px-4 text-lg" } = $$props;
  let { asideClass = "absolute w-auto h-screen bg-white border-r-2 shadow-lg z-50" } = $$props;
  let { navDivClass = "pb-10" } = $$props;
  let { sideBarListClass = "border-b border-gray-400 mb-2 px-4" } = $$props;
  let { transitionParams = {} } = $$props;
  let { transitionType = "fly" } = $$props;
  function multiple(node, params) {
    switch (transitionType) {
      case "slide":
        return slide(node, params);
      case "blur":
        return blur(node, params);
      case "fly":
        return fly(node, params);
      case "fade":
        return fade(node, params);
    }
  }
  let inert = null;
  let sidebarStatus;
  let ariaHidden;
  sidebarOpen.subscribe((value) => {
    if (value === true) {
      $$invalidate(17, sidebarStatus = true);
      $$invalidate(18, ariaHidden = false);
    } else {
      $$invalidate(17, sidebarStatus = false);
      $$invalidate(18, ariaHidden = true);
    }
  });
  $$self.$$.on_mount.push(function() {
    if (lists === void 0 && !("lists" in $$props || $$self.$$.bound[$$self.$$.props["lists"]])) {
      console.warn("<Sidebar> was created without expected prop 'lists'");
    }
  });
  const writable_props = [
    "lists",
    "alt",
    "hamburgerClass",
    "headerClass",
    "logo",
    "logoClass",
    "navBarClass",
    "siteName",
    "siteClass",
    "spanClass",
    "navClass",
    "asideClass",
    "navDivClass",
    "sideBarListClass",
    "transitionParams",
    "transitionType"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Sidebar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("lists" in $$props2)
      $$invalidate(0, lists = $$props2.lists);
    if ("alt" in $$props2)
      $$invalidate(1, alt = $$props2.alt);
    if ("hamburgerClass" in $$props2)
      $$invalidate(2, hamburgerClass = $$props2.hamburgerClass);
    if ("headerClass" in $$props2)
      $$invalidate(3, headerClass = $$props2.headerClass);
    if ("logo" in $$props2)
      $$invalidate(4, logo = $$props2.logo);
    if ("logoClass" in $$props2)
      $$invalidate(5, logoClass = $$props2.logoClass);
    if ("navBarClass" in $$props2)
      $$invalidate(6, navBarClass = $$props2.navBarClass);
    if ("siteName" in $$props2)
      $$invalidate(7, siteName = $$props2.siteName);
    if ("siteClass" in $$props2)
      $$invalidate(8, siteClass = $$props2.siteClass);
    if ("spanClass" in $$props2)
      $$invalidate(9, spanClass = $$props2.spanClass);
    if ("navClass" in $$props2)
      $$invalidate(10, navClass = $$props2.navClass);
    if ("asideClass" in $$props2)
      $$invalidate(11, asideClass = $$props2.asideClass);
    if ("navDivClass" in $$props2)
      $$invalidate(12, navDivClass = $$props2.navDivClass);
    if ("sideBarListClass" in $$props2)
      $$invalidate(13, sideBarListClass = $$props2.sideBarListClass);
    if ("transitionParams" in $$props2)
      $$invalidate(14, transitionParams = $$props2.transitionParams);
    if ("transitionType" in $$props2)
      $$invalidate(15, transitionType = $$props2.transitionType);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    sidebarOpen,
    sidebarIsInert,
    fly,
    slide,
    blur,
    fade,
    SidebarList: SidebarList_default,
    Navbar: Navbar_default,
    OutsideClick: OutsideClick_default,
    lists,
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navBarClass,
    siteName,
    siteClass,
    spanClass,
    navClass,
    asideClass,
    navDivClass,
    sideBarListClass,
    transitionParams,
    transitionType,
    multiple,
    inert,
    sidebarStatus,
    ariaHidden,
    $sidebarIsInert
  });
  $$self.$inject_state = ($$props2) => {
    if ("lists" in $$props2)
      $$invalidate(0, lists = $$props2.lists);
    if ("alt" in $$props2)
      $$invalidate(1, alt = $$props2.alt);
    if ("hamburgerClass" in $$props2)
      $$invalidate(2, hamburgerClass = $$props2.hamburgerClass);
    if ("headerClass" in $$props2)
      $$invalidate(3, headerClass = $$props2.headerClass);
    if ("logo" in $$props2)
      $$invalidate(4, logo = $$props2.logo);
    if ("logoClass" in $$props2)
      $$invalidate(5, logoClass = $$props2.logoClass);
    if ("navBarClass" in $$props2)
      $$invalidate(6, navBarClass = $$props2.navBarClass);
    if ("siteName" in $$props2)
      $$invalidate(7, siteName = $$props2.siteName);
    if ("siteClass" in $$props2)
      $$invalidate(8, siteClass = $$props2.siteClass);
    if ("spanClass" in $$props2)
      $$invalidate(9, spanClass = $$props2.spanClass);
    if ("navClass" in $$props2)
      $$invalidate(10, navClass = $$props2.navClass);
    if ("asideClass" in $$props2)
      $$invalidate(11, asideClass = $$props2.asideClass);
    if ("navDivClass" in $$props2)
      $$invalidate(12, navDivClass = $$props2.navDivClass);
    if ("sideBarListClass" in $$props2)
      $$invalidate(13, sideBarListClass = $$props2.sideBarListClass);
    if ("transitionParams" in $$props2)
      $$invalidate(14, transitionParams = $$props2.transitionParams);
    if ("transitionType" in $$props2)
      $$invalidate(15, transitionType = $$props2.transitionType);
    if ("inert" in $$props2)
      $$invalidate(16, inert = $$props2.inert);
    if ("sidebarStatus" in $$props2)
      $$invalidate(17, sidebarStatus = $$props2.sidebarStatus);
    if ("ariaHidden" in $$props2)
      $$invalidate(18, ariaHidden = $$props2.ariaHidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1048576) {
      $:
        $$invalidate(16, inert = $sidebarIsInert ? "inert" : null);
    }
  };
  return [
    lists,
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navBarClass,
    siteName,
    siteClass,
    spanClass,
    navClass,
    asideClass,
    navDivClass,
    sideBarListClass,
    transitionParams,
    transitionType,
    inert,
    sidebarStatus,
    ariaHidden,
    multiple,
    $sidebarIsInert,
    slots,
    $$scope
  ];
}
var Sidebar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        lists: 0,
        alt: 1,
        hamburgerClass: 2,
        headerClass: 3,
        logo: 4,
        logoClass: 5,
        navBarClass: 6,
        siteName: 7,
        siteClass: 8,
        spanClass: 9,
        navClass: 10,
        asideClass: 11,
        navDivClass: 12,
        sideBarListClass: 13,
        transitionParams: 14,
        transitionType: 15
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sidebar",
      options,
      id: create_fragment6.name
    });
  }
  get lists() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lists(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hamburgerClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hamburgerClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logo() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logo(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logoClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logoClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navBarClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navBarClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteName() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteName(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spanClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spanClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asideClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asideClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navDivClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navDivClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sideBarListClass() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideBarListClass(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionParams() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionParams(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionType() {
    throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionType(value) {
    throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Sidebar_default = Sidebar;

// node_modules/svelte-sidebar-menu/SidebarList.svelte
var file6 = "node_modules/svelte-sidebar-menu/SidebarList.svelte";
function create_else_block2(ctx) {
  let div;
  let a;
  let t;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { class: true, href: true, rel: true });
      var a_nodes = children(a);
      t = claim_text(a_nodes, ctx[1]);
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "class", "block");
      attr_dev(a, "href", ctx[0]);
      attr_dev(a, "rel", ctx[2]);
      add_location(a, file6, 20, 2, 664);
      attr_dev(div, "class", div_class_value = ctx[3] + " " + (ctx[6].class ? ctx[6].class : ""));
      add_location(div, file6, 19, 1, 592);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      append_hydration_dev(a, t);
      if (!mounted) {
        dispose = listen_dev(a, "click", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
      if (dirty & 1) {
        attr_dev(a, "href", ctx2[0]);
      }
      if (dirty & 4) {
        attr_dev(a, "rel", ctx2[2]);
      }
      if (dirty & 72 && div_class_value !== (div_class_value = ctx2[3] + " " + (ctx2[6].class ? ctx2[6].class : ""))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(19:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let a;
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { class: true, href: true, rel: true });
      var a_nodes = children(a);
      t = claim_text(a_nodes, ctx[1]);
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "class", "block");
      attr_dev(a, "href", ctx[0]);
      attr_dev(a, "rel", ctx[2]);
      add_location(a, file6, 16, 2, 534);
      attr_dev(div, "class", div_class_value = ctx[3] + " " + (ctx[6].class ? ctx[6].class : ""));
      add_location(div, file6, 15, 1, 462);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      append_hydration_dev(a, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
      if (dirty & 1) {
        attr_dev(a, "href", ctx2[0]);
      }
      if (dirty & 4) {
        attr_dev(a, "rel", ctx2[2]);
      }
      if (dirty & 72 && div_class_value !== (div_class_value = ctx2[3] + " " + (ctx2[6].class ? ctx2[6].class : ""))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(15:0) {#if $sidebarStayOpen === true}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4] === true)
      return create_if_block3;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let $sidebarStayOpen;
  validate_store(sidebarStayOpen, "sidebarStayOpen");
  component_subscribe($$self, sidebarStayOpen, ($$value) => $$invalidate(4, $sidebarStayOpen = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SidebarList", slots, []);
  let { href } = $$props;
  let { name } = $$props;
  let { rel = null } = $$props;
  let { sideBarListClass = "border-b border-gray-400 mb-2 px-4" } = $$props;
  function toggleSide() {
    if (!sidebarStayOpen) {
      sidebarOpen.update((n) => n = !n);
      sidebarIsInert.update((n) => n = !n);
    }
  }
  $$self.$$.on_mount.push(function() {
    if (href === void 0 && !("href" in $$props || $$self.$$.bound[$$self.$$.props["href"]])) {
      console.warn("<SidebarList> was created without expected prop 'href'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<SidebarList> was created without expected prop 'name'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("rel" in $$new_props)
      $$invalidate(2, rel = $$new_props.rel);
    if ("sideBarListClass" in $$new_props)
      $$invalidate(3, sideBarListClass = $$new_props.sideBarListClass);
  };
  $$self.$capture_state = () => ({
    sidebarOpen,
    sidebarIsInert,
    sidebarStayOpen,
    href,
    name,
    rel,
    sideBarListClass,
    toggleSide,
    $sidebarStayOpen
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("rel" in $$props)
      $$invalidate(2, rel = $$new_props.rel);
    if ("sideBarListClass" in $$props)
      $$invalidate(3, sideBarListClass = $$new_props.sideBarListClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [href, name, rel, sideBarListClass, $sidebarStayOpen, toggleSide, $$props];
}
var SidebarList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      href: 0,
      name: 1,
      rel: 2,
      sideBarListClass: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SidebarList",
      options,
      id: create_fragment7.name
    });
  }
  get href() {
    throw new Error("<SidebarList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<SidebarList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<SidebarList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<SidebarList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rel() {
    throw new Error("<SidebarList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rel(value) {
    throw new Error("<SidebarList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sideBarListClass() {
    throw new Error("<SidebarList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideBarListClass(value) {
    throw new Error("<SidebarList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SidebarList_default = SidebarList;

// node_modules/svelte-sidebar-menu/Dropdown.svelte
var file7 = "node_modules/svelte-sidebar-menu/Dropdown.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i].href;
  child_ctx[4] = list[i].name;
  child_ctx[12] = list[i].rel;
  child_ctx[13] = list[i].id;
  return child_ctx;
}
function create_if_block4(ctx) {
  let div;
  const block_1 = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "fixed w-full h-full inset-0");
      add_location(div, file7, 20, 1, 781);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block4.name,
    type: "if",
    source: "(20:0) {#if hidden === false}",
    ctx
  });
  return block_1;
}
function create_each_block2(ctx) {
  let li;
  let a;
  let t0_value = ctx[4] + "";
  let t0;
  let a_href_value;
  let a_id_value;
  let a_rel_value;
  let t1;
  const block_1 = {
    c: function create() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", {
        href: true,
        id: true,
        rel: true,
        class: true
      });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      a_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = ctx[11]);
      attr_dev(a, "id", a_id_value = ctx[13]);
      attr_dev(a, "rel", a_rel_value = ctx[12]);
      attr_dev(a, "class", ctx[2]);
      add_location(a, file7, 47, 5, 1509);
      add_location(li, file7, 46, 4, 1499);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      append_hydration_dev(a, t0);
      append_hydration_dev(li, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[4] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & 1 && a_href_value !== (a_href_value = ctx2[11])) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty & 1 && a_id_value !== (a_id_value = ctx2[13])) {
        attr_dev(a, "id", a_id_value);
      }
      if (dirty & 1 && a_rel_value !== (a_rel_value = ctx2[12])) {
        attr_dev(a, "rel", a_rel_value);
      }
      if (dirty & 4) {
        attr_dev(a, "class", ctx2[2]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_each_block2.name,
    type: "each",
    source: "(46:3) {#each child as { href, name, rel, id }}",
    ctx
  });
  return block_1;
}
function create_fragment8(ctx) {
  let t0;
  let li;
  let button;
  let t1;
  let t2;
  let svg;
  let path;
  let t3;
  let div;
  let ul;
  let div_class_value;
  let mounted;
  let dispose;
  let if_block = ctx[5] === false && create_if_block4(ctx);
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block_1 = {
    c: function create() {
      if (if_block)
        if_block.c();
      t0 = space();
      li = element("li");
      button = element("button");
      t1 = text(ctx[4]);
      t2 = space();
      svg = svg_element("svg");
      path = svg_element("path");
      t3 = space();
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t0 = claim_space(nodes);
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t1 = claim_text(button_nodes, ctx[4]);
      t2 = claim_space(button_nodes);
      svg = claim_svg_element(button_nodes, "svg", {
        class: true,
        fill: true,
        viewBox: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      t3 = claim_space(li_nodes);
      div = claim_element(li_nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      ul = claim_element(div_nodes, "UL", { class: true, "aria-label": true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "d", "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file7, 30, 4, 1027);
      attr_dev(svg, "class", "ml-1 w-4 h-4");
      attr_dev(svg, "fill", "currentColor");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file7, 25, 2, 910);
      attr_dev(button, "class", ctx[3]);
      add_location(button, file7, 23, 1, 837);
      attr_dev(ul, "class", "py-1");
      attr_dev(ul, "aria-label", "dropdown-button");
      add_location(ul, file7, 44, 2, 1404);
      attr_dev(div, "class", div_class_value = ctx[1] + " " + (ctx[8].class ? ctx[8].class : ""));
      set_style(div, "position", "absolute");
      set_style(div, "margin", "0px");
      toggle_class(div, "hidden", ctx[5]);
      toggle_class(div, "block", ctx[6]);
      add_location(div, file7, 38, 1, 1255);
      add_location(li, file7, 22, 0, 831);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, button);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, t2);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, path);
      append_hydration_dev(li, t3);
      append_hydration_dev(li, div);
      append_hydration_dev(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[9], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[5] === false) {
        if (if_block) {
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 16)
        set_data_dev(t1, ctx2[4]);
      if (dirty & 8) {
        attr_dev(button, "class", ctx2[3]);
      }
      if (dirty & 5) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 258 && div_class_value !== (div_class_value = ctx2[1] + " " + (ctx2[8].class ? ctx2[8].class : ""))) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & 290) {
        toggle_class(div, "hidden", ctx2[5]);
      }
      if (dirty & 322) {
        toggle_class(div, "block", ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(li);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dropdown", slots, []);
  let { name = "" } = $$props;
  let { child } = $$props;
  let { activeDropdownDiv = "z-10 w-44 text-lg list-none bg-white rounded divide-y divide-gray-100 shadow" } = $$props;
  let { activeChildLi = "block py-2 px-4 text-base text-gray-700 hover:bg-gray-100" } = $$props;
  let { dropdownLi = "flex justify-between items-center py-2 pr-4 pl-3 w-full text-base font-medium text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:w-auto" } = $$props;
  let hidden = true;
  let block = false;
  const handleDropdown = () => {
    $$invalidate(5, hidden = !hidden);
    $$invalidate(6, block = !block);
  };
  const closeDropdown = () => {
    $$invalidate(5, hidden = true);
    $$invalidate(6, block = false);
  };
  $$self.$$.on_mount.push(function() {
    if (child === void 0 && !("child" in $$props || $$self.$$.bound[$$self.$$.props["child"]])) {
      console.warn("<Dropdown> was created without expected prop 'child'");
    }
  });
  const click_handler = () => handleDropdown();
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(4, name = $$new_props.name);
    if ("child" in $$new_props)
      $$invalidate(0, child = $$new_props.child);
    if ("activeDropdownDiv" in $$new_props)
      $$invalidate(1, activeDropdownDiv = $$new_props.activeDropdownDiv);
    if ("activeChildLi" in $$new_props)
      $$invalidate(2, activeChildLi = $$new_props.activeChildLi);
    if ("dropdownLi" in $$new_props)
      $$invalidate(3, dropdownLi = $$new_props.dropdownLi);
  };
  $$self.$capture_state = () => ({
    name,
    child,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    hidden,
    block,
    handleDropdown,
    closeDropdown
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(4, name = $$new_props.name);
    if ("child" in $$props)
      $$invalidate(0, child = $$new_props.child);
    if ("activeDropdownDiv" in $$props)
      $$invalidate(1, activeDropdownDiv = $$new_props.activeDropdownDiv);
    if ("activeChildLi" in $$props)
      $$invalidate(2, activeChildLi = $$new_props.activeChildLi);
    if ("dropdownLi" in $$props)
      $$invalidate(3, dropdownLi = $$new_props.dropdownLi);
    if ("hidden" in $$props)
      $$invalidate(5, hidden = $$new_props.hidden);
    if ("block" in $$props)
      $$invalidate(6, block = $$new_props.block);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    child,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    name,
    hidden,
    block,
    handleDropdown,
    $$props,
    click_handler
  ];
}
var Dropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      name: 4,
      child: 0,
      activeDropdownDiv: 1,
      activeChildLi: 2,
      dropdownLi: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dropdown",
      options,
      id: create_fragment8.name
    });
  }
  get name() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get child() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set child(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeDropdownDiv() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeDropdownDiv(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeChildLi() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeChildLi(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdownLi() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdownLi(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dropdown_default = Dropdown;

// node_modules/svelte-sidebar-menu/TopMenu.svelte
var file8 = "node_modules/svelte-sidebar-menu/TopMenu.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i].id;
  child_ctx[13] = list[i].name;
  child_ctx[14] = list[i].href;
  child_ctx[15] = list[i].rel;
  child_ctx[16] = list[i].child;
  return child_ctx;
}
function create_else_block3(ctx) {
  let li;
  let a;
  let t0_value = ctx[13] + "";
  let t0;
  let a_href_value;
  let a_rel_value;
  let t1;
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", { href: true, rel: true, class: true });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      a_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = ctx[14]);
      attr_dev(a, "rel", a_rel_value = ctx[15]);
      attr_dev(a, "class", ctx[2]);
      toggle_class(a, "active", window.location.href === ctx[14]);
      add_location(a, file8, 49, 6, 3045);
      attr_dev(li, "class", ctx[6]);
      add_location(li, file8, 48, 5, 3020);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      append_hydration_dev(a, t0);
      append_hydration_dev(li, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16 && t0_value !== (t0_value = ctx2[13] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & 16 && a_href_value !== (a_href_value = ctx2[14])) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty & 16 && a_rel_value !== (a_rel_value = ctx2[15])) {
        attr_dev(a, "rel", a_rel_value);
      }
      if (dirty & 4) {
        attr_dev(a, "class", ctx2[2]);
      }
      if (dirty & 20) {
        toggle_class(a, "active", window.location.href === ctx2[14]);
      }
      if (dirty & 64) {
        attr_dev(li, "class", ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(48:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let dropdown;
  let current;
  dropdown = new Dropdown_default({
    props: {
      name: ctx[13],
      child: ctx[16],
      activeChildLi: ctx[8],
      activeDropdownDiv: ctx[7],
      dropdownLi: ctx[9]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dropdown.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dropdown.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dropdown, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dropdown_changes = {};
      if (dirty & 16)
        dropdown_changes.name = ctx2[13];
      if (dirty & 16)
        dropdown_changes.child = ctx2[16];
      if (dirty & 256)
        dropdown_changes.activeChildLi = ctx2[8];
      if (dirty & 128)
        dropdown_changes.activeDropdownDiv = ctx2[7];
      if (dirty & 512)
        dropdown_changes.dropdownLi = ctx2[9];
      dropdown.$set(dropdown_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dropdown, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(46:4) {#if child}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[16])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(45:3) {#each topMenus as { id, name, href, rel, child }}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let div1;
  let button0;
  let svg0;
  let path0;
  let t0;
  let button1;
  let svg1;
  let path1;
  let t1;
  let div0;
  let ul;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[4];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div1 = element("div");
      button0 = element("button");
      svg0 = svg_element("svg");
      path0 = svg_element("path");
      t0 = space();
      button1 = element("button");
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      t1 = space();
      div0 = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      button0 = claim_element(div1_nodes, "BUTTON", {
        "data-collapse-toggle": true,
        type: true,
        class: true,
        "aria-expanded": true
      });
      var button0_nodes = children(button0);
      svg0 = claim_svg_element(button0_nodes, "svg", {
        fill: true,
        stroke: true,
        "stroke-width": true,
        viewBox: true,
        xmlns: true,
        class: true
      });
      var svg0_nodes = children(svg0);
      path0 = claim_svg_element(svg0_nodes, "path", {
        d: true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      children(path0).forEach(detach_dev);
      svg0_nodes.forEach(detach_dev);
      button0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      button1 = claim_element(div1_nodes, "BUTTON", {
        "data-collapse-toggle": true,
        type: true,
        class: true,
        "aria-expanded": true
      });
      var button1_nodes = children(button1);
      svg1 = claim_svg_element(button1_nodes, "svg", {
        fill: true,
        stroke: true,
        "stroke-width": true,
        viewBox: true,
        xmlns: true,
        class: true
      });
      var svg1_nodes = children(svg1);
      path1 = claim_svg_element(svg1_nodes, "path", {
        d: true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      children(path1).forEach(detach_dev);
      svg1_nodes.forEach(detach_dev);
      button1_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true, id: true });
      var div0_nodes = children(div0);
      ul = claim_element(div0_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0118 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3l1.5 1.5 3-3.75");
      attr_dev(path0, "stroke-linecap", "round");
      attr_dev(path0, "stroke-linejoin", "round");
      add_location(path0, file8, 28, 2, 1663);
      attr_dev(svg0, "fill", "none");
      attr_dev(svg0, "stroke", "currentColor");
      attr_dev(svg0, "stroke-width", "1.5");
      attr_dev(svg0, "viewBox", "0 0 24 24");
      attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg0, "class", "text-green-500 mr-2 dark:text-pink-500 w-6 h-6");
      add_location(svg0, file8, 27, 0, 1492);
      attr_dev(button0, "data-collapse-toggle", "mobile-menu");
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", ctx[1]);
      attr_dev(button0, "aria-expanded", "false");
      add_location(button0, file8, 20, 1, 1354);
      attr_dev(path1, "d", "M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1");
      attr_dev(path1, "stroke-linecap", "round");
      attr_dev(path1, "stroke-linejoin", "round");
      add_location(path1, file8, 39, 2, 2593);
      attr_dev(svg1, "fill", "none");
      attr_dev(svg1, "stroke", "currentColor");
      attr_dev(svg1, "stroke-width", "1.5");
      attr_dev(svg1, "viewBox", "0 0 24 24");
      attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg1, "class", "text-green-500 mr-2 dark:text-pink-500 w-6 h-6");
      add_location(svg1, file8, 38, 2, 2422);
      attr_dev(button1, "data-collapse-toggle", "mobile-menu");
      attr_dev(button1, "type", "button");
      attr_dev(button1, "class", ctx[1]);
      attr_dev(button1, "aria-expanded", "false");
      add_location(button1, file8, 31, 0, 2282);
      attr_dev(ul, "class", ctx[5]);
      add_location(ul, file8, 43, 2, 2832);
      attr_dev(div0, "class", ctx[0]);
      attr_dev(div0, "id", "mobile-menu");
      toggle_class(div0, "hidden", ctx[10]);
      add_location(div0, file8, 42, 1, 2767);
      attr_dev(div1, "class", ctx[3]);
      add_location(div1, file8, 19, 0, 1328);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, button0);
      append_hydration_dev(button0, svg0);
      append_hydration_dev(svg0, path0);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, button1);
      append_hydration_dev(button1, svg1);
      append_hydration_dev(svg1, path1);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button0, "click", ctx[11], false, false, false),
          listen_dev(button1, "click", ctx[11], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 2) {
        attr_dev(button0, "class", ctx2[1]);
      }
      if (!current || dirty & 2) {
        attr_dev(button1, "class", ctx2[1]);
      }
      if (dirty & 980) {
        each_value = ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 32) {
        attr_dev(ul, "class", ctx2[5]);
      }
      if (!current || dirty & 1) {
        attr_dev(div0, "class", ctx2[0]);
      }
      if (!current || dirty & 1025) {
        toggle_class(div0, "hidden", ctx2[10]);
      }
      if (!current || dirty & 8) {
        attr_dev(div1, "class", ctx2[3]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TopMenu", slots, []);
  let { topDiv = "w-full md:block md:w-auto" } = $$props;
  let { buttonClass = "inline-flex items-center text-base text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200" } = $$props;
  let { childLi = "block py-2 pr-4 pl-3  text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 text-base" } = $$props;
  let { topMenuDiv = "container flex flex-wrap justify-end mx-auto" } = $$props;
  let { topMenus } = $$props;
  let { topul = "flex flex-col mt-4 md:flex-row md:space-x-8 md:mt-0 md:text-md md:font-medium pt-1 bg-gray-200" } = $$props;
  let { topli = "block py-2 pr-4 pl-3 text-gray-700 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0" } = $$props;
  let { activeDropdownDiv = "z-10 w-44 text-lg list-none bg-white rounded divide-y divide-gray-100 shadow" } = $$props;
  let { activeChildLi = "block py-2 px-4 text-base text-gray-700 hover:bg-gray-100" } = $$props;
  let { dropdownLi = "flex justify-between items-center py-2 pr-4 pl-3 w-full text-base font-medium text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:w-auto" } = $$props;
  let barHidden = true;
  const handleClickbtn = () => {
    $$invalidate(10, barHidden = !barHidden);
  };
  $$self.$$.on_mount.push(function() {
    if (topMenus === void 0 && !("topMenus" in $$props || $$self.$$.bound[$$self.$$.props["topMenus"]])) {
      console.warn("<TopMenu> was created without expected prop 'topMenus'");
    }
  });
  const writable_props = [
    "topDiv",
    "buttonClass",
    "childLi",
    "topMenuDiv",
    "topMenus",
    "topul",
    "topli",
    "activeDropdownDiv",
    "activeChildLi",
    "dropdownLi"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TopMenu> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("topDiv" in $$props2)
      $$invalidate(0, topDiv = $$props2.topDiv);
    if ("buttonClass" in $$props2)
      $$invalidate(1, buttonClass = $$props2.buttonClass);
    if ("childLi" in $$props2)
      $$invalidate(2, childLi = $$props2.childLi);
    if ("topMenuDiv" in $$props2)
      $$invalidate(3, topMenuDiv = $$props2.topMenuDiv);
    if ("topMenus" in $$props2)
      $$invalidate(4, topMenus = $$props2.topMenus);
    if ("topul" in $$props2)
      $$invalidate(5, topul = $$props2.topul);
    if ("topli" in $$props2)
      $$invalidate(6, topli = $$props2.topli);
    if ("activeDropdownDiv" in $$props2)
      $$invalidate(7, activeDropdownDiv = $$props2.activeDropdownDiv);
    if ("activeChildLi" in $$props2)
      $$invalidate(8, activeChildLi = $$props2.activeChildLi);
    if ("dropdownLi" in $$props2)
      $$invalidate(9, dropdownLi = $$props2.dropdownLi);
  };
  $$self.$capture_state = () => ({
    Dropdown: Dropdown_default,
    topDiv,
    buttonClass,
    childLi,
    topMenuDiv,
    topMenus,
    topul,
    topli,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    barHidden,
    handleClickbtn
  });
  $$self.$inject_state = ($$props2) => {
    if ("topDiv" in $$props2)
      $$invalidate(0, topDiv = $$props2.topDiv);
    if ("buttonClass" in $$props2)
      $$invalidate(1, buttonClass = $$props2.buttonClass);
    if ("childLi" in $$props2)
      $$invalidate(2, childLi = $$props2.childLi);
    if ("topMenuDiv" in $$props2)
      $$invalidate(3, topMenuDiv = $$props2.topMenuDiv);
    if ("topMenus" in $$props2)
      $$invalidate(4, topMenus = $$props2.topMenus);
    if ("topul" in $$props2)
      $$invalidate(5, topul = $$props2.topul);
    if ("topli" in $$props2)
      $$invalidate(6, topli = $$props2.topli);
    if ("activeDropdownDiv" in $$props2)
      $$invalidate(7, activeDropdownDiv = $$props2.activeDropdownDiv);
    if ("activeChildLi" in $$props2)
      $$invalidate(8, activeChildLi = $$props2.activeChildLi);
    if ("dropdownLi" in $$props2)
      $$invalidate(9, dropdownLi = $$props2.dropdownLi);
    if ("barHidden" in $$props2)
      $$invalidate(10, barHidden = $$props2.barHidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    topDiv,
    buttonClass,
    childLi,
    topMenuDiv,
    topMenus,
    topul,
    topli,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    barHidden,
    handleClickbtn
  ];
}
var TopMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      topDiv: 0,
      buttonClass: 1,
      childLi: 2,
      topMenuDiv: 3,
      topMenus: 4,
      topul: 5,
      topli: 6,
      activeDropdownDiv: 7,
      activeChildLi: 8,
      dropdownLi: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TopMenu",
      options,
      id: create_fragment9.name
    });
  }
  get topDiv() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topDiv(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClass() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClass(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get childLi() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set childLi(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topMenuDiv() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topMenuDiv(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topMenus() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topMenus(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topul() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topul(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topli() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topli(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeDropdownDiv() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeDropdownDiv(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeChildLi() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeChildLi(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdownLi() {
    throw new Error("<TopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdownLi(value) {
    throw new Error("<TopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TopMenu_default = TopMenu;

// node_modules/svelte-sidebar-menu/Side.svelte
var file9 = "node_modules/svelte-sidebar-menu/Side.svelte";
function create_else_block4(ctx) {
  let div;
  let navbar;
  let t;
  let outsideclick;
  let current;
  navbar = new Navbar_default({
    props: {
      alt: ctx[0],
      hamburgerClass: ctx[1],
      headerClass: ctx[2],
      logo: ctx[3],
      logoClass: ctx[4],
      navClass: ctx[5],
      siteClass: ctx[6],
      siteName: ctx[7],
      spanClass: ctx[8],
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  outsideclick = new OutsideClick_default({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(navbar.$$.fragment);
      t = space();
      create_component(outsideclick.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(navbar.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      claim_component(outsideclick.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", ctx[22]);
      add_location(div, file9, 70, 1, 2758);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(navbar, div, null);
      append_hydration_dev(div, t);
      mount_component(outsideclick, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navbar_changes = {};
      if (dirty & 1)
        navbar_changes.alt = ctx2[0];
      if (dirty & 2)
        navbar_changes.hamburgerClass = ctx2[1];
      if (dirty & 4)
        navbar_changes.headerClass = ctx2[2];
      if (dirty & 8)
        navbar_changes.logo = ctx2[3];
      if (dirty & 16)
        navbar_changes.logoClass = ctx2[4];
      if (dirty & 32)
        navbar_changes.navClass = ctx2[5];
      if (dirty & 64)
        navbar_changes.siteClass = ctx2[6];
      if (dirty & 128)
        navbar_changes.siteName = ctx2[7];
      if (dirty & 256)
        navbar_changes.spanClass = ctx2[8];
      if (dirty & 34078208) {
        navbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navbar.$set(navbar_changes);
      const outsideclick_changes = {};
      if (dirty & 37224448) {
        outsideclick_changes.$$scope = { dirty, ctx: ctx2 };
      }
      outsideclick.$set(outsideclick_changes);
      if (!current || dirty & 4194304) {
        attr_dev(div, "class", ctx2[22]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navbar.$$.fragment, local);
      transition_in(outsideclick.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navbar.$$.fragment, local);
      transition_out(outsideclick.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(navbar);
      destroy_component(outsideclick);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(70:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let outsideclick;
  let current;
  outsideclick = new OutsideClick_default({
    props: {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(outsideclick.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(outsideclick.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(outsideclick, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const outsideclick_changes = {};
      if (dirty & 41943039) {
        outsideclick_changes.$$scope = { dirty, ctx: ctx2 };
      }
      outsideclick.$set(outsideclick_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(outsideclick.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(outsideclick.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(outsideclick, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(37:0) {#if $sidebarOpen}",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let topmenu;
  let current;
  topmenu = new TopMenu_default({
    props: {
      buttonClass: ctx[10],
      childLi: ctx[11],
      topDiv: ctx[9],
      topMenuDiv: ctx[12],
      topMenus: ctx[13],
      topul: ctx[14],
      topli: ctx[15],
      activeDropdownDiv: ctx[16],
      activeChildLi: ctx[17],
      dropdownLi: ctx[18]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(topmenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(topmenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(topmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const topmenu_changes = {};
      if (dirty & 1024)
        topmenu_changes.buttonClass = ctx2[10];
      if (dirty & 2048)
        topmenu_changes.childLi = ctx2[11];
      if (dirty & 512)
        topmenu_changes.topDiv = ctx2[9];
      if (dirty & 4096)
        topmenu_changes.topMenuDiv = ctx2[12];
      if (dirty & 8192)
        topmenu_changes.topMenus = ctx2[13];
      if (dirty & 16384)
        topmenu_changes.topul = ctx2[14];
      if (dirty & 32768)
        topmenu_changes.topli = ctx2[15];
      if (dirty & 65536)
        topmenu_changes.activeDropdownDiv = ctx2[16];
      if (dirty & 131072)
        topmenu_changes.activeChildLi = ctx2[17];
      if (dirty & 262144)
        topmenu_changes.dropdownLi = ctx2[18];
      topmenu.$set(topmenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(topmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(topmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(topmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(72:2) <Navbar    {alt}    {hamburgerClass}    {headerClass}    {logo}    {logoClass}    {navClass}    {siteClass}    {siteName}    {spanClass}   >",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let current;
  const default_slot_template = ctx[24].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[25], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(default_slot_template, ctx2[25], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(97:3) <Aside {asideClass} {transitionType} {transitionParams}>",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let aside;
  let current;
  aside = new Aside_default({
    props: {
      asideClass: ctx[19],
      transitionType: ctx[21],
      transitionParams: ctx[20],
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(aside.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(aside.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(aside, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const aside_changes = {};
      if (dirty & 524288)
        aside_changes.asideClass = ctx2[19];
      if (dirty & 2097152)
        aside_changes.transitionType = ctx2[21];
      if (dirty & 1048576)
        aside_changes.transitionParams = ctx2[20];
      if (dirty & 33554432) {
        aside_changes.$$scope = { dirty, ctx: ctx2 };
      }
      aside.$set(aside_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(aside.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(aside.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(aside, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(96:2) <OutsideClick>",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let topmenu;
  let current;
  topmenu = new TopMenu_default({
    props: {
      buttonClass: ctx[10],
      childLi: ctx[11],
      topDiv: ctx[9],
      topMenuDiv: ctx[12],
      topMenus: ctx[13],
      topul: ctx[14],
      topli: ctx[15],
      activeDropdownDiv: ctx[16],
      activeChildLi: ctx[17],
      dropdownLi: ctx[18]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(topmenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(topmenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(topmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const topmenu_changes = {};
      if (dirty & 1024)
        topmenu_changes.buttonClass = ctx2[10];
      if (dirty & 2048)
        topmenu_changes.childLi = ctx2[11];
      if (dirty & 512)
        topmenu_changes.topDiv = ctx2[9];
      if (dirty & 4096)
        topmenu_changes.topMenuDiv = ctx2[12];
      if (dirty & 8192)
        topmenu_changes.topMenus = ctx2[13];
      if (dirty & 16384)
        topmenu_changes.topul = ctx2[14];
      if (dirty & 32768)
        topmenu_changes.topli = ctx2[15];
      if (dirty & 65536)
        topmenu_changes.activeDropdownDiv = ctx2[16];
      if (dirty & 131072)
        topmenu_changes.activeChildLi = ctx2[17];
      if (dirty & 262144)
        topmenu_changes.dropdownLi = ctx2[18];
      topmenu.$set(topmenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(topmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(topmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(topmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(40:3) <Navbar     {alt}     {hamburgerClass}     {headerClass}     {logo}     {logoClass}     {navClass}     {siteClass}     {siteName}     {spanClass}    >",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let current;
  const default_slot_template = ctx[24].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[25], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(default_slot_template, ctx2[25], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(65:3) <Aside {asideClass} {transitionType} {transitionParams}>",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let div;
  let navbar;
  let t;
  let aside;
  let current;
  navbar = new Navbar_default({
    props: {
      alt: ctx[0],
      hamburgerClass: ctx[1],
      headerClass: ctx[2],
      logo: ctx[3],
      logoClass: ctx[4],
      navClass: ctx[5],
      siteClass: ctx[6],
      siteName: ctx[7],
      spanClass: ctx[8],
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  aside = new Aside_default({
    props: {
      asideClass: ctx[19],
      transitionType: ctx[21],
      transitionParams: ctx[20],
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(navbar.$$.fragment);
      t = space();
      create_component(aside.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(navbar.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      claim_component(aside.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", ctx[22]);
      add_location(div, file9, 38, 2, 2247);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(navbar, div, null);
      append_hydration_dev(div, t);
      mount_component(aside, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navbar_changes = {};
      if (dirty & 1)
        navbar_changes.alt = ctx2[0];
      if (dirty & 2)
        navbar_changes.hamburgerClass = ctx2[1];
      if (dirty & 4)
        navbar_changes.headerClass = ctx2[2];
      if (dirty & 8)
        navbar_changes.logo = ctx2[3];
      if (dirty & 16)
        navbar_changes.logoClass = ctx2[4];
      if (dirty & 32)
        navbar_changes.navClass = ctx2[5];
      if (dirty & 64)
        navbar_changes.siteClass = ctx2[6];
      if (dirty & 128)
        navbar_changes.siteName = ctx2[7];
      if (dirty & 256)
        navbar_changes.spanClass = ctx2[8];
      if (dirty & 34078208) {
        navbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navbar.$set(navbar_changes);
      const aside_changes = {};
      if (dirty & 524288)
        aside_changes.asideClass = ctx2[19];
      if (dirty & 2097152)
        aside_changes.transitionType = ctx2[21];
      if (dirty & 1048576)
        aside_changes.transitionParams = ctx2[20];
      if (dirty & 33554432) {
        aside_changes.$$scope = { dirty, ctx: ctx2 };
      }
      aside.$set(aside_changes);
      if (!current || dirty & 4194304) {
        attr_dev(div, "class", ctx2[22]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navbar.$$.fragment, local);
      transition_in(aside.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navbar.$$.fragment, local);
      transition_out(aside.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(navbar);
      destroy_component(aside);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(38:1) <OutsideClick>",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[23])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let $sidebarOpen;
  validate_store(sidebarOpen, "sidebarOpen");
  component_subscribe($$self, sidebarOpen, ($$value) => $$invalidate(23, $sidebarOpen = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Side", slots, ["default"]);
  let { alt = "" } = $$props;
  let { hamburgerClass = "text-gray-500 hover:text-gray-700 cursor-pointer mr-4 border-none focus:outline-none lg:hidden" } = $$props;
  let { headerClass = "bg-gray-200 pt-4 px-10 items-center text-gray-600" } = $$props;
  let { logo = "" } = $$props;
  let { logoClass = "" } = $$props;
  let { navClass = "flex relative" } = $$props;
  let { siteClass = "w-1/4 h-12 text-lg pt-1 pl-12" } = $$props;
  let { siteName = "Demo" } = $$props;
  let { spanClass = "pl-2 self-center text-lg font-semibold text-gray-900 whitespace-nowrap" } = $$props;
  let { topDiv = "w-full md:block md:w-auto" } = $$props;
  let { buttonClass = "inline-flex items-center text-base text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200" } = $$props;
  let { childLi = "block py-2 pr-4 pl-3  text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 text-base" } = $$props;
  let { topMenuDiv = "container flex flex-wrap justify-end mx-auto" } = $$props;
  let { topMenus } = $$props;
  let { topul = "flex flex-col mt-4 md:flex-row md:space-x-8 md:mt-0 md:text-md md:font-medium pt-1 bg-white" } = $$props;
  let { topli = "block py-2 pr-4 pl-3 text-gray-700 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0" } = $$props;
  let { activeDropdownDiv = "z-10 w-44 text-lg list-none bg-white rounded divide-y divide-gray-100 shadow" } = $$props;
  let { activeChildLi = "block py-2 px-4 text-base text-gray-700 hover:bg-gray-100" } = $$props;
  let { dropdownLi = "flex justify-between items-center py-2 pr-4 pl-3 w-full text-base font-medium text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:w-auto" } = $$props;
  let { asideClass = "absolute w-auto border-r-2 shadow-lg z-50 bg-white h-screen overflow-scroll" } = $$props;
  let { transitionParams = {} } = $$props;
  let { transitionType = "fly" } = $$props;
  let { sideWrapperClass = "fixed z-50 top-0 left-0 w-full" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (topMenus === void 0 && !("topMenus" in $$props || $$self.$$.bound[$$self.$$.props["topMenus"]])) {
      console.warn("<Side> was created without expected prop 'topMenus'");
    }
  });
  const writable_props = [
    "alt",
    "hamburgerClass",
    "headerClass",
    "logo",
    "logoClass",
    "navClass",
    "siteClass",
    "siteName",
    "spanClass",
    "topDiv",
    "buttonClass",
    "childLi",
    "topMenuDiv",
    "topMenus",
    "topul",
    "topli",
    "activeDropdownDiv",
    "activeChildLi",
    "dropdownLi",
    "asideClass",
    "transitionParams",
    "transitionType",
    "sideWrapperClass"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Side> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("alt" in $$props2)
      $$invalidate(0, alt = $$props2.alt);
    if ("hamburgerClass" in $$props2)
      $$invalidate(1, hamburgerClass = $$props2.hamburgerClass);
    if ("headerClass" in $$props2)
      $$invalidate(2, headerClass = $$props2.headerClass);
    if ("logo" in $$props2)
      $$invalidate(3, logo = $$props2.logo);
    if ("logoClass" in $$props2)
      $$invalidate(4, logoClass = $$props2.logoClass);
    if ("navClass" in $$props2)
      $$invalidate(5, navClass = $$props2.navClass);
    if ("siteClass" in $$props2)
      $$invalidate(6, siteClass = $$props2.siteClass);
    if ("siteName" in $$props2)
      $$invalidate(7, siteName = $$props2.siteName);
    if ("spanClass" in $$props2)
      $$invalidate(8, spanClass = $$props2.spanClass);
    if ("topDiv" in $$props2)
      $$invalidate(9, topDiv = $$props2.topDiv);
    if ("buttonClass" in $$props2)
      $$invalidate(10, buttonClass = $$props2.buttonClass);
    if ("childLi" in $$props2)
      $$invalidate(11, childLi = $$props2.childLi);
    if ("topMenuDiv" in $$props2)
      $$invalidate(12, topMenuDiv = $$props2.topMenuDiv);
    if ("topMenus" in $$props2)
      $$invalidate(13, topMenus = $$props2.topMenus);
    if ("topul" in $$props2)
      $$invalidate(14, topul = $$props2.topul);
    if ("topli" in $$props2)
      $$invalidate(15, topli = $$props2.topli);
    if ("activeDropdownDiv" in $$props2)
      $$invalidate(16, activeDropdownDiv = $$props2.activeDropdownDiv);
    if ("activeChildLi" in $$props2)
      $$invalidate(17, activeChildLi = $$props2.activeChildLi);
    if ("dropdownLi" in $$props2)
      $$invalidate(18, dropdownLi = $$props2.dropdownLi);
    if ("asideClass" in $$props2)
      $$invalidate(19, asideClass = $$props2.asideClass);
    if ("transitionParams" in $$props2)
      $$invalidate(20, transitionParams = $$props2.transitionParams);
    if ("transitionType" in $$props2)
      $$invalidate(21, transitionType = $$props2.transitionType);
    if ("sideWrapperClass" in $$props2)
      $$invalidate(22, sideWrapperClass = $$props2.sideWrapperClass);
    if ("$$scope" in $$props2)
      $$invalidate(25, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Aside: Aside_default,
    Navbar: Navbar_default,
    TopMenu: TopMenu_default,
    OutsideClick: OutsideClick_default,
    sidebarOpen,
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navClass,
    siteClass,
    siteName,
    spanClass,
    topDiv,
    buttonClass,
    childLi,
    topMenuDiv,
    topMenus,
    topul,
    topli,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    asideClass,
    transitionParams,
    transitionType,
    sideWrapperClass,
    $sidebarOpen
  });
  $$self.$inject_state = ($$props2) => {
    if ("alt" in $$props2)
      $$invalidate(0, alt = $$props2.alt);
    if ("hamburgerClass" in $$props2)
      $$invalidate(1, hamburgerClass = $$props2.hamburgerClass);
    if ("headerClass" in $$props2)
      $$invalidate(2, headerClass = $$props2.headerClass);
    if ("logo" in $$props2)
      $$invalidate(3, logo = $$props2.logo);
    if ("logoClass" in $$props2)
      $$invalidate(4, logoClass = $$props2.logoClass);
    if ("navClass" in $$props2)
      $$invalidate(5, navClass = $$props2.navClass);
    if ("siteClass" in $$props2)
      $$invalidate(6, siteClass = $$props2.siteClass);
    if ("siteName" in $$props2)
      $$invalidate(7, siteName = $$props2.siteName);
    if ("spanClass" in $$props2)
      $$invalidate(8, spanClass = $$props2.spanClass);
    if ("topDiv" in $$props2)
      $$invalidate(9, topDiv = $$props2.topDiv);
    if ("buttonClass" in $$props2)
      $$invalidate(10, buttonClass = $$props2.buttonClass);
    if ("childLi" in $$props2)
      $$invalidate(11, childLi = $$props2.childLi);
    if ("topMenuDiv" in $$props2)
      $$invalidate(12, topMenuDiv = $$props2.topMenuDiv);
    if ("topMenus" in $$props2)
      $$invalidate(13, topMenus = $$props2.topMenus);
    if ("topul" in $$props2)
      $$invalidate(14, topul = $$props2.topul);
    if ("topli" in $$props2)
      $$invalidate(15, topli = $$props2.topli);
    if ("activeDropdownDiv" in $$props2)
      $$invalidate(16, activeDropdownDiv = $$props2.activeDropdownDiv);
    if ("activeChildLi" in $$props2)
      $$invalidate(17, activeChildLi = $$props2.activeChildLi);
    if ("dropdownLi" in $$props2)
      $$invalidate(18, dropdownLi = $$props2.dropdownLi);
    if ("asideClass" in $$props2)
      $$invalidate(19, asideClass = $$props2.asideClass);
    if ("transitionParams" in $$props2)
      $$invalidate(20, transitionParams = $$props2.transitionParams);
    if ("transitionType" in $$props2)
      $$invalidate(21, transitionType = $$props2.transitionType);
    if ("sideWrapperClass" in $$props2)
      $$invalidate(22, sideWrapperClass = $$props2.sideWrapperClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    alt,
    hamburgerClass,
    headerClass,
    logo,
    logoClass,
    navClass,
    siteClass,
    siteName,
    spanClass,
    topDiv,
    buttonClass,
    childLi,
    topMenuDiv,
    topMenus,
    topul,
    topli,
    activeDropdownDiv,
    activeChildLi,
    dropdownLi,
    asideClass,
    transitionParams,
    transitionType,
    sideWrapperClass,
    $sidebarOpen,
    slots,
    $$scope
  ];
}
var Side = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      alt: 0,
      hamburgerClass: 1,
      headerClass: 2,
      logo: 3,
      logoClass: 4,
      navClass: 5,
      siteClass: 6,
      siteName: 7,
      spanClass: 8,
      topDiv: 9,
      buttonClass: 10,
      childLi: 11,
      topMenuDiv: 12,
      topMenus: 13,
      topul: 14,
      topli: 15,
      activeDropdownDiv: 16,
      activeChildLi: 17,
      dropdownLi: 18,
      asideClass: 19,
      transitionParams: 20,
      transitionType: 21,
      sideWrapperClass: 22
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Side",
      options,
      id: create_fragment10.name
    });
  }
  get alt() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hamburgerClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hamburgerClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logo() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logo(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logoClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logoClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteName() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteName(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spanClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spanClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topDiv() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topDiv(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get childLi() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set childLi(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topMenuDiv() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topMenuDiv(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topMenus() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topMenus(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topul() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topul(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topli() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topli(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeDropdownDiv() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeDropdownDiv(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeChildLi() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeChildLi(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdownLi() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdownLi(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asideClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asideClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionParams() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionParams(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionType() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionType(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sideWrapperClass() {
    throw new Error("<Side>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideWrapperClass(value) {
    throw new Error("<Side>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Side_default = Side;

// node_modules/svelte-sidebar-menu/click_outside.js
function clickOutside(node) {
  const handleClick = (event) => {
    if (!node.contains(event.target)) {
      node.dispatchEvent(new CustomEvent("outclick"));
    }
  };
  document.addEventListener("click", handleClick, true);
  return {
    destroy() {
      document.removeEventListener("click", handleClick, true);
    }
  };
}

// node_modules/svelte-sidebar-menu/OutsideClick.svelte
var file10 = "node_modules/svelte-sidebar-menu/OutsideClick.svelte";
function create_fragment11(ctx) {
  let div;
  let clickOutside_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file10, 11, 0, 337);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(clickOutside_action = clickOutside.call(null, div)),
          listen_dev(div, "outclick", ctx[0], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let $sidebarStayOpen;
  validate_store(sidebarStayOpen, "sidebarStayOpen");
  component_subscribe($$self, sidebarStayOpen, ($$value) => $$invalidate(3, $sidebarStayOpen = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OutsideClick", slots, ["default"]);
  const handleOutClick = () => {
    if ($sidebarStayOpen === false) {
      sidebarOpen.update((n) => n = false);
      sidebarIsInert.update((n) => n = true);
    }
  };
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<OutsideClick> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    clickOutside,
    sidebarOpen,
    sidebarIsInert,
    sidebarStayOpen,
    handleOutClick,
    $sidebarStayOpen
  });
  return [handleOutClick, $$scope, slots];
}
var OutsideClick = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OutsideClick",
      options,
      id: create_fragment11.name
    });
  }
};
var OutsideClick_default = OutsideClick;
export {
  Aside_default as Aside,
  Nav_default as Nav,
  Navbar_default as Navbar,
  OutsideClick_default as OutsideClick,
  Responsive_default as Responsive,
  Side_default as Side,
  Sidebar_default as Sidebar,
  SidebarList_default as SidebarList,
  TopMenu_default as TopMenu,
  clickOutside,
  sidebarIsInert,
  sidebarOpen,
  sidebarStayOpen
};
//# sourceMappingURL=svelte-sidebar-menu.js.map
